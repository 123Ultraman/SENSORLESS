%implements s2_b0_w4wyd_Functions "C"

%function c2wgnvw4uy_Fcn0(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
hgyzgm1py1 *emxArray;
int32_T i;
*pEmxArray = (hgyzgm1py1 *)malloc(sizeof(hgyzgm1py1));
emxArray = *pEmxArray;
emxArray->data = (char_T *)NULL;
emxArray->numDimensions = numDimensions;
emxArray->size = (int32_T *)malloc(sizeof(int32_T) * (uint32_T)numDimensions);
emxArray->allocatedSize = 0;
emxArray->canFreeData = true;
for (i = 0; i < numDimensions; i++) {
    emxArray->size[i] = 0;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void c2wgnvw4uy(\
%assign comma = ""
%<comma>hgyzgm1py1 **pEmxArray\
%assign comma = ", "
%<comma>int32_T numDimensions\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 0, fcnProtoType)>
%return fcnBuff
%endfunction

%function mw2mi4zvh2_Fcn1(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
ftbvbe5nvy *emxArray;
int32_T i;
*pEmxArray = (ftbvbe5nvy *)malloc(sizeof(ftbvbe5nvy));
emxArray = *pEmxArray;
emxArray->data = (uint8_T *)NULL;
emxArray->numDimensions = numDimensions;
emxArray->size = (int32_T *)malloc(sizeof(int32_T) * (uint32_T)numDimensions);
emxArray->allocatedSize = 0;
emxArray->canFreeData = true;
for (i = 0; i < numDimensions; i++) {
    emxArray->size[i] = 0;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void mw2mi4zvh2(\
%assign comma = ""
%<comma>ftbvbe5nvy **pEmxArray\
%assign comma = ", "
%<comma>int32_T numDimensions\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 1, fcnProtoType)>
%return fcnBuff
%endfunction

%function gilqgzxw0n_Fcn2(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,2,0,0)
%<SLibCG_AccessArg(0 ,2, 0)>
%endif

%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&pStruct->ExampleData", "2"], 0, 2, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void gilqgzxw0n(\
%assign comma = ""
%<comma>i0lstc3zfvr *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 2, fcnProtoType)>
%return fcnBuff
%endfunction

%function ctyecsexru_Fcn3(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,3,0,0)
%<SLibCG_AccessArg(0 ,3, 0)>
%endif

%<(SLibCGCallSubFcn("gilqgzxw0n", ["&pStruct->InputStream"], 0, 3, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void ctyecsexru(\
%assign comma = ""
%<comma>kw1nls53yow *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 3, fcnProtoType)>
%return fcnBuff
%endfunction

%function aoooaxuzdi_Fcn4(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,4,1,0)
%<SLibCG_AccessArg(0 ,4, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,4,0,0)
%<SLibCG_AccessArg(0 ,4, 0)>
%endif

%<(SLibCGCallSubFcn("ctyecsexru", ["&pStruct->UnreadDataBuffer"], 0, 4, 0))>;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&pStruct->ByteOrder", "2"], 0, 4, 1))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void aoooaxuzdi(\
%assign comma = ""
%<comma>habembxjygt *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 4, fcnProtoType)>
%return fcnBuff
%endfunction

%function ctyecsexru4_Fcn5(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,5,0,0)
%<SLibCG_AccessArg(0 ,5, 0)>
%endif

%<(SLibCGCallSubFcn("gilqgzxw0n", ["&pStruct->InputStream"], 0, 5, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void ctyecsexru4(\
%assign comma = ""
%<comma>afxtk4erg3r *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 5, fcnProtoType)>
%return fcnBuff
%endfunction

%function dvff4meo5c_Fcn6(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,6,6,0)
%<SLibCG_AccessArg(0 ,6, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,6,5,0)
%<SLibCG_AccessArg(0 ,6, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,6,4,0)
%<SLibCG_AccessArg(0 ,6, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,6,3,0)
%<SLibCG_AccessArg(0 ,6, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,6,2,0)
%<SLibCG_AccessArg(0 ,6, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,6,1,0)
%<SLibCG_AccessArg(0 ,6, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,6,0,0)
%<SLibCG_AccessArg(0 ,6, 0)>
%endif

%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&pStruct->ByteOrder", "2"], 0, 6, 0))>;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&pStruct->NativeDataType", "2"], 0, 6, 1))>;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&pStruct->DataFieldName", "2"], 0, 6, 2))>;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&pStruct->FlowControl", "2"], 0, 6, 3))>;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&pStruct->Parity", "2"], 0, 6, 4))>;
%<(SLibCGCallSubFcn("aoooaxuzdi", ["&pStruct->_pobj0"], 0, 6, 5))>;
%<(SLibCGCallSubFcn("ctyecsexru4", ["&pStruct->_pobj1"], 0, 6, 6))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void dvff4meo5c(\
%assign comma = ""
%<comma>fops2f5bc43 *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 6, fcnProtoType)>
%return fcnBuff
%endfunction

%function k5hgq1ezni_Fcn7(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,7,0,0)
%<SLibCG_AccessArg(0 ,7, 0)>
%endif

%<(SLibCGCallSubFcn("dvff4meo5c", ["&pStruct->SerialObj"], 0, 7, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void k5hgq1ezni(\
%assign comma = ""
%<comma>evr2nhlpli *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 7, fcnProtoType)>
%return fcnBuff
%endfunction

%function kjimvvt0ge_Fcn8(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T b_k;
int32_T len;
len = 0;
b_k = 0;
while ((b_k < 4096) && (!(in[b_k] == '\x00'))) {
    len++;
    b_k++;
}
if (len < 1) {
    len = 0;
}
out_size[0] = 1;
out_size[1] = len;
if (len - 1 >= 0) {
    memcpy(&out_data[0], &in[0], (uint32_T)len * sizeof(char_T));
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void kjimvvt0ge(\
%assign comma = ""
%<comma>const char_T in[4096]\
%assign comma = ", "
%<comma>char_T out_data[]\
%assign comma = ", "
%<comma>int32_T out_size[2]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 8, fcnProtoType)>
%return fcnBuff
%endfunction

%function fptaaqsn5k_Fcn9(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
int32_T newNumel;
void *newData;
if (oldNumel < 0) {
    oldNumel = 0;
}
newNumel = 1;
for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel *= emxArray->size[i];
}
if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
        i = 16;
    }
    while (i < newNumel) {
        if (i > 1073741823) {
            i = MAX_int32_T;
        } else {
            i <<= 1;
        }
    }
    newData = malloc((uint32_T)i * sizeof(uint8_T));
    if (emxArray->data != NULL) {
        memcpy(newData, emxArray->data, sizeof(uint8_T) * (uint32_T)oldNumel);
        if (emxArray->canFreeData) {
            free(emxArray->data);
        }
    }
    emxArray->data = (uint8_T *)newData;
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void fptaaqsn5k(\
%assign comma = ""
%<comma>ftbvbe5nvy *emxArray\
%assign comma = ", "
%<comma>int32_T oldNumel\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 9, fcnProtoType)>
%return fcnBuff
%endfunction

%function nokkyn0chrz_Fcn10(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
afxtk4erg3r *obj_p;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T hasSyncError;
obj_p = obj->AsyncIOChannel;
chImpl = obj_p->ChannelImpl;
success = coderChannelIsOpen(chImpl, &hasSyncError);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void nokkyn0chrz(\
%assign comma = ""
%<comma>fops2f5bc43 *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 10, fcnProtoType)>
%return fcnBuff
%endfunction

%function lcng5t0i0zp_Fcn11(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
afxtk4erg3r *obj_p;
real_T b_value;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T hasSyncError;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,11,0,0)
%<SLibCG_AccessArg(0 ,11, 0)>
%endif

if (!obj->IsSharingExistingTimeout) {
    b_value = obj->Timeout;
} else {
    %<(SLibCGCallSubFcn("nokkyn0chrz", ["obj"], 0, 11, 0))>;
    obj_p = obj->AsyncIOChannel;
    chImpl = obj_p->ChannelImpl;
    success = coderChannelExecute(chImpl, "GetSharedTimeout", 0);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
    obj_p = obj->AsyncIOChannel;
    b_value = obj_p->CustomProps.SharedTimeout;
    chImpl = obj_p->ChannelImpl;
    success = coderChannelGetPropertyValue(chImpl, "SharedTimeout", "double", 1, &b_value);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
return b_value;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static real_T lcng5t0i0zp(\
%assign comma = ""
%<comma>fops2f5bc43 *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 11, fcnProtoType)>
%return fcnBuff
%endfunction

%function kt1e3yths5_Fcn12(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
int32_T newNumel;
void *newData;
if (oldNumel < 0) {
    oldNumel = 0;
}
newNumel = 1;
for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel *= emxArray->size[i];
}
if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
        i = 16;
    }
    while (i < newNumel) {
        if (i > 1073741823) {
            i = MAX_int32_T;
        } else {
            i <<= 1;
        }
    }
    newData = malloc((uint32_T)i * sizeof(char_T));
    if (emxArray->data != NULL) {
        memcpy(newData, emxArray->data, sizeof(char_T) * (uint32_T)oldNumel);
        if (emxArray->canFreeData) {
            free(emxArray->data);
        }
    }
    emxArray->data = (char_T *)newData;
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void kt1e3yths5(\
%assign comma = ""
%<comma>hgyzgm1py1 *emxArray\
%assign comma = ", "
%<comma>int32_T oldNumel\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 12, fcnProtoType)>
%return fcnBuff
%endfunction

%function kh2gvvgen0t_Fcn13(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
CoderInputStream streamImpl;
CoderOutputStream streamImpl_p;
afxtk4erg3r *channel;
habembxjygt *obj_p;
real_T e[2];
real_T f[2];
real_T varargin_8[2];
int32_T success;
char_T converterPlugin_data[4096];
char_T deviceFullPath_data[4096];
char_T devicePath_data[4096];
char_T devicePlugin_data[4096];
char_T localAbsPath[4096];
char_T errorID[1024];
char_T errorText[1024];
char_T b[5];
char_T d[4];
char_T g[4];
boolean_T hasSyncError;
boolean_T result;
static const char_T tmp[13] = %<(TLC_STR_CTX(0))>;
int32_T deviceFullPath_size[2];
int32_T converterPlugin_size_idx_1;
int32_T devicePath_size_idx_1;
int32_T devicePlugin_size_idx_1;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,13,9,0)
%<SLibCG_AccessArg(0 ,13, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,13,8,0)
%<SLibCG_AccessArg(0 ,13, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,13,7,0)
%<SLibCG_AccessArg(0 ,13, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,13,4,0)
%<SLibCG_AccessArg(0 ,13, 0)>
%endif

for (success = 0; success < 5; success++) {
    b[success] = obj->Port[success];
}
coderComputeAbsolutePath("serialdevice.dll", &localAbsPath[0]);
%<(SLibCGCallSubFcn("kjimvvt0ge", ["localAbsPath", "deviceFullPath_data", "deviceFullPath_size"], 0, 13, 0))>;
if (deviceFullPath_size[1] != 0) {
    devicePlugin_size_idx_1 = deviceFullPath_size[1];
    success = deviceFullPath_size[1];
    memcpy(&devicePlugin_data[0], &deviceFullPath_data[0], (uint32_T)success * sizeof(char_T));
} else {
    coderComputeAbsolutePath("%<TLC_STR_CTX(1)>", &localAbsPath[0]);
    %<(SLibCGCallSubFcn("kjimvvt0ge", ["localAbsPath", "deviceFullPath_data", "deviceFullPath_size"], 0, 13, 1))>;
    if (deviceFullPath_size[1] != 0) {
        devicePlugin_size_idx_1 = deviceFullPath_size[1];
        success = deviceFullPath_size[1];
        memcpy(&devicePlugin_data[0], &deviceFullPath_data[0], (uint32_T)success * sizeof(char_T));
    }
}
coderComputeAbsolutePath("serialcoderconverter.dll", &localAbsPath[0]);
%<(SLibCGCallSubFcn("kjimvvt0ge", ["localAbsPath", "deviceFullPath_data", "deviceFullPath_size"], 0, 13, 2))>;
if (deviceFullPath_size[1] != 0) {
    converterPlugin_size_idx_1 = deviceFullPath_size[1];
    success = deviceFullPath_size[1];
    memcpy(&converterPlugin_data[0], &deviceFullPath_data[0], (uint32_T)success * sizeof(char_T));
} else {
    coderComputeAbsolutePath("%<TLC_STR_CTX(2)>", &localAbsPath[0]);
    %<(SLibCGCallSubFcn("kjimvvt0ge", ["localAbsPath", "deviceFullPath_data", "deviceFullPath_size"], 0, 13, 3))>;
    if (deviceFullPath_size[1] != 0) {
        converterPlugin_size_idx_1 = deviceFullPath_size[1];
        success = deviceFullPath_size[1];
        memcpy(&converterPlugin_data[0], &deviceFullPath_data[0], (uint32_T)success * sizeof(char_T));
    }
}
varargin_8[0] = obj->InputBufferSize;
varargin_8[1] = obj->OutputBufferSize;
iobj_1->CustomProps.CTS = true;
iobj_1->CustomProps.DSR = true;
iobj_1->CustomProps.CD = true;
iobj_1->CustomProps.RING = true;
iobj_1->CustomProps.InitAccess = true;
iobj_1->CustomProps.SharedTimeout = 0.0;
iobj_1->CustomProps.LatestNumBytesWrittenToDevice = 0ULL;
iobj_1->CustomProps.TotalBytesWritten = 0ULL;
iobj_1->ChannelImpl = 0;
memcpy(&rtB.b_devicePluginPath_data_mbvzarwird[0], &devicePlugin_data[0], (uint32_T)devicePlugin_size_idx_1 * sizeof(char_T));
rtB.b_devicePluginPath_data_mbvzarwird[devicePlugin_size_idx_1] = '\x00';
memcpy(&rtB.b_converterPluginPath_data_cl54gopm0x[0], &converterPlugin_data[0], (uint32_T)converterPlugin_size_idx_1 * sizeof(char_T));
rtB.b_converterPluginPath_data_cl54gopm0x[converterPlugin_size_idx_1] = '\x00';
chImpl = coderChannelCreate(&rtB.b_devicePluginPath_data_mbvzarwird[0], &rtB.b_converterPluginPath_data_cl54gopm0x[0], varargin_8[0], varargin_8[1], &errorID[0], &errorText[0]);
iobj_1->ChannelImpl = chImpl;
chImpl = iobj_1->ChannelImpl;
varargin_8[0] = 9600.0;
varargin_8[1] = 9600.0;
d[0] = 'n';
d[1] = 'o';
d[2] = 'n';
d[3] = 'e';
e[0] = 1.0;
f[0] = 8.0;
e[1] = 1.0;
f[1] = 8.0;
g[0] = 'n';
g[1] = 'o';
g[2] = 'n';
g[3] = 'e';
success = coderChannelInit(chImpl, 6, "ServiceName", "char", 5, &b[0], "BaudRate", "double", 1, &varargin_8[0], "Parity", "char", 4, &d[0], "StopBits", "double", 1, &e[0], "DataBits", "double", 1, &f[0], "FlowControl", "char", 4, &g[0]);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
chImpl = iobj_1->ChannelImpl;
streamImpl = coderChannelGetInputStream(chImpl);
iobj_1->InputStream.StreamImpl = streamImpl;
success = iobj_1->InputStream.ExampleData->size[0] * iobj_1->InputStream.ExampleData->size[1];
iobj_1->InputStream.ExampleData->size[0] = 1;
iobj_1->InputStream.ExampleData->size[1] = 1;
%<(SLibCGCallSubFcn("fptaaqsn5k", ["iobj_1->InputStream.ExampleData", "success"], 0, 13, 7))>;
iobj_1->InputStream.ExampleData->data[0] = 0U;
iobj_1->InputStream.matlabCodegenIsDeleted = false;
chImpl = iobj_1->ChannelImpl;
streamImpl_p = coderChannelGetOutputStream(chImpl);
iobj_1->OutputStream.StreamImpl = streamImpl_p;
iobj_1->OutputStream.matlabCodegenIsDeleted = false;
iobj_1->matlabCodegenIsDeleted = false;
obj->AsyncIOChannel = iobj_1;
if ((!obj->IsSharingPort) || (!obj->IsSharingExistingTimeout)) {
    %<(SLibCGCallSubFcn("lcng5t0i0zp", ["obj"], 0, 13, 4))>;
}
channel = obj->AsyncIOChannel;
iobj_0->AsyncIOChannel = channel;
success = iobj_0->ByteOrder->size[0] * iobj_0->ByteOrder->size[1];
iobj_0->ByteOrder->size[0] = 1;
iobj_0->ByteOrder->size[1] = 0;
iobj_0->ByteOrder->size[0] = 1;
iobj_0->ByteOrder->size[1] = 13;
%<(SLibCGCallSubFcn("kt1e3yths5", ["iobj_0->ByteOrder", "success"], 0, 13, 8))>;
for (success = 0; success < 13; success++) {
    iobj_0->ByteOrder->data[success] = tmp[success];
}
coderComputeAbsolutePath("buffer.dll", &localAbsPath[0]);
%<(SLibCGCallSubFcn("kjimvvt0ge", ["localAbsPath", "deviceFullPath_data", "deviceFullPath_size"], 0, 13, 5))>;
if (deviceFullPath_size[1] != 0) {
    devicePath_size_idx_1 = deviceFullPath_size[1];
    success = deviceFullPath_size[1];
    memcpy(&devicePath_data[0], &deviceFullPath_data[0], (uint32_T)success * sizeof(char_T));
} else {
    coderComputeAbsolutePath("%<TLC_STR_CTX(3)>", &localAbsPath[0]);
    %<(SLibCGCallSubFcn("kjimvvt0ge", ["localAbsPath", "deviceFullPath_data", "deviceFullPath_size"], 0, 13, 6))>;
    if (deviceFullPath_size[1] != 0) {
        devicePath_size_idx_1 = deviceFullPath_size[1];
        success = deviceFullPath_size[1];
        memcpy(&devicePath_data[0], &deviceFullPath_data[0], (uint32_T)success * sizeof(char_T));
    }
}
iobj_0->UnreadDataBuffer.ChannelImpl = 0;
memcpy(&rtB.b_devicePluginPath_data_mbvzarwird[0], &devicePath_data[0], (uint32_T)devicePath_size_idx_1 * sizeof(char_T));
rtB.b_devicePluginPath_data_mbvzarwird[devicePath_size_idx_1] = '\x00';
chImpl = coderChannelCreate(&rtB.b_devicePluginPath_data_mbvzarwird[0], "%<TLC_STR_CTX(4)>", %<LibGetMathConstant(LibRealNonFinite("inf"), FcnGetDataTypeIdFromName("double"))>, 0.0, &errorID[0], &errorText[0]);
iobj_0->UnreadDataBuffer.ChannelImpl = chImpl;
chImpl = iobj_0->UnreadDataBuffer.ChannelImpl;
success = coderChannelInit(chImpl, 0);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
chImpl = iobj_0->UnreadDataBuffer.ChannelImpl;
streamImpl = coderChannelGetInputStream(chImpl);
iobj_0->UnreadDataBuffer.InputStream.StreamImpl = streamImpl;
success = iobj_0->UnreadDataBuffer.InputStream.ExampleData->size[0] * iobj_0->UnreadDataBuffer.InputStream.ExampleData->size[1];
iobj_0->UnreadDataBuffer.InputStream.ExampleData->size[0] = 1;
iobj_0->UnreadDataBuffer.InputStream.ExampleData->size[1] = 1;
%<(SLibCGCallSubFcn("fptaaqsn5k", ["iobj_0->UnreadDataBuffer.InputStream.ExampleData", "success"], 0, 13, 9))>;
iobj_0->UnreadDataBuffer.InputStream.ExampleData->data[0] = 0U;
iobj_0->UnreadDataBuffer.InputStream.matlabCodegenIsDeleted = false;
chImpl = iobj_0->UnreadDataBuffer.ChannelImpl;
streamImpl_p = coderChannelGetOutputStream(chImpl);
iobj_0->UnreadDataBuffer.OutputStream.StreamImpl = streamImpl_p;
iobj_0->UnreadDataBuffer.OutputStream.matlabCodegenIsDeleted = false;
iobj_0->UnreadDataBuffer.matlabCodegenIsDeleted = false;
chImpl = iobj_0->UnreadDataBuffer.ChannelImpl;
success = coderChannelIsOpen(chImpl, &result);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
if (!result) {
    chImpl = iobj_0->UnreadDataBuffer.ChannelImpl;
    success = coderChannelOpen(chImpl, 0);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
iobj_0->matlabCodegenIsDeleted = false;
obj->TransportChannel = iobj_0;
obj_p = obj->TransportChannel;
success = obj_p->ByteOrder->size[0] * obj_p->ByteOrder->size[1];
obj_p->ByteOrder->size[0] = 1;
obj_p->ByteOrder->size[1] = 0;
obj_p->ByteOrder->size[0] = 1;
obj_p->ByteOrder->size[1] = 13;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj_p->ByteOrder", "success"], 0, 13, 10))>;
for (success = 0; success < 13; success++) {
    obj_p->ByteOrder->data[success] = tmp[success];
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void kh2gvvgen0t(\
%assign comma = ""
%<comma>fops2f5bc43 *obj\
%assign comma = ", "
%<comma>habembxjygt *iobj_0\
%assign comma = ", "
%<comma>afxtk4erg3r *iobj_1\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 13, fcnProtoType)>
%return fcnBuff
%endfunction

%function o4wczq2e3h0_Fcn14(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
afxtk4erg3r *obj_p;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T b_value;
boolean_T hasSyncError;
obj_p = obj->AsyncIOChannel;
chImpl = obj_p->ChannelImpl;
success = coderChannelIsOpen(chImpl, &b_value);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
return b_value;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static boolean_T o4wczq2e3h0(\
%assign comma = ""
%<comma>fops2f5bc43 *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 14, fcnProtoType)>
%return fcnBuff
%endfunction

%function ec2asd4d0o_Fcn15(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
if (*pEmxArray != (hgyzgm1py1 *)NULL) {
    if (((*pEmxArray)->data != (char_T *)NULL) && (*pEmxArray)->canFreeData) {
        free((*pEmxArray)->data);
    }
    free((*pEmxArray)->size);
    free(*pEmxArray);
    *pEmxArray = (hgyzgm1py1 *)NULL;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void ec2asd4d0o(\
%assign comma = ""
%<comma>hgyzgm1py1 **pEmxArray\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 15, fcnProtoType)>
%return fcnBuff
%endfunction

%function dyeylk2zzmj_Fcn16(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
afxtk4erg3r *obj_p;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T b_value;
boolean_T hasSyncError;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,16,0,0)
%<SLibCG_AccessArg(0 ,16, 0)>
%endif

%<(SLibCGCallSubFcn("nokkyn0chrz", ["obj"], 0, 16, 0))>;
obj_p = obj->AsyncIOChannel;
chImpl = obj_p->ChannelImpl;
success = coderChannelExecute(chImpl, "GetInitAccessStatus", 0);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
obj_p = obj->AsyncIOChannel;
b_value = obj_p->CustomProps.InitAccess;
chImpl = obj_p->ChannelImpl;
success = coderChannelGetPropertyValue(chImpl, "InitAccess", "logical", 1, &b_value);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
return b_value;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static boolean_T dyeylk2zzmj(\
%assign comma = ""
%<comma>fops2f5bc43 *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 16, fcnProtoType)>
%return fcnBuff
%endfunction

%function l1feuv03fpleou_Fcn17(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T b_kstr;
int32_T minnanb;
boolean_T b_bool;
static const char_T tmp[128] = %<(TLC_STR_CTX(5))>;
static const char_T tmp_p[13] = %<(TLC_STR_CTX(6))>;
int32_T exitg1;
boolean_T guard1;
b_bool = false;
b_kstr = a->size[1];
minnanb = muIntScalarMin_sint32(b_kstr, 13);
guard1 = false;
if ((int32_T)cmpLen <= minnanb) {
    b_kstr = (int32_T)cmpLen;
    minnanb = muIntScalarMin_sint32(minnanb, b_kstr);
    guard1 = true;
} else if (a->size[1] == 13) {
    minnanb = 13;
    guard1 = true;
}
if (guard1) {
    b_kstr = 1;
    do {
        exitg1 = 0;
        if (b_kstr - 1 <= (uint8_T)minnanb - 1) {
            if (tmp[(int32_T)((uint8_T)a->data[b_kstr - 1] & 127U)] != tmp[(int32_T)tmp_p[b_kstr - 1]]) {
                exitg1 = 1;
            } else {
                b_kstr++;
            }
        } else {
            b_bool = true;
            exitg1 = 1;
        }
    } while (exitg1 == 0);
}
return b_bool;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static boolean_T l1feuv03fpleou(\
%assign comma = ""
%<comma>const hgyzgm1py1 *a\
%assign comma = ", "
%<comma>real_T cmpLen\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 17, fcnProtoType)>
%return fcnBuff
%endfunction

%function ltdh5g0hxx_Fcn18(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
afxtk4erg3r *obj_p;
habembxjygt *obj_e;
hgyzgm1py1 *d;
hgyzgm1py1 *d_value;
hgyzgm1py1 *options_FlowControl;
hgyzgm1py1 *options_Parity;
real_T c[2];
real_T e[2];
real_T f[2];
real_T out;
real_T out_e;
real_T out_p;
int32_T loop_ub;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
char_T b_value_data[13];
char_T b[5];
boolean_T h[2];
boolean_T i[2];
boolean_T j[2];
boolean_T hasSyncError;
boolean_T options_IsSharingExistingTimeout;
boolean_T options_IsSharingPort;
boolean_T options_IsWriteOnly;
boolean_T result;
static const char_T b_b[10] = %<(TLC_STR_CTX(7))>;
static const char_T tmp[13] = %<(TLC_STR_CTX(8))>;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,18,4,0)
%<SLibCG_AccessArg(0 ,18, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,18,3,0)
%<SLibCG_AccessArg(0 ,18, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,18,2,0)
%<SLibCG_AccessArg(0 ,18, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,18,0,0)
%<SLibCG_AccessArg(0 ,18, 0)>
%endif

obj_p = obj->AsyncIOChannel;
chImpl = obj_p->ChannelImpl;
success = coderChannelIsOpen(chImpl, &result);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
for (success = 0; success < 5; success++) {
    b[success] = obj->Port[success];
}
out = obj->BaudRate;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&options_Parity", "2"], 0, 18, 13))>;
success = options_Parity->size[0] * options_Parity->size[1];
options_Parity->size[0] = 1;
options_Parity->size[1] = obj->Parity->size[1];
%<(SLibCGCallSubFcn("kt1e3yths5", ["options_Parity", "success"], 0, 18, 5))>;
loop_ub = obj->Parity->size[1];
for (success = 0; success < loop_ub; success++) {
    options_Parity->data[success] = obj->Parity->data[success];
}
out_p = obj->StopBits;
out_e = obj->DataBits;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&options_FlowControl", "2"], 0, 18, 14))>;
success = options_FlowControl->size[0] * options_FlowControl->size[1];
options_FlowControl->size[0] = 1;
options_FlowControl->size[1] = obj->FlowControl->size[1];
%<(SLibCGCallSubFcn("kt1e3yths5", ["options_FlowControl", "success"], 0, 18, 6))>;
loop_ub = obj->FlowControl->size[1];
for (success = 0; success < loop_ub; success++) {
    options_FlowControl->data[success] = obj->FlowControl->data[success];
}
options_IsWriteOnly = obj->IsWriteOnly;
options_IsSharingPort = obj->IsSharingPort;
options_IsSharingExistingTimeout = obj->IsSharingExistingTimeout;
obj_p = obj->AsyncIOChannel;
chImpl = obj_p->ChannelImpl;
success = coderChannelIsOpen(chImpl, &result);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&d_value", "2"], 0, 18, 16))>;
if (!result) {
    chImpl = obj_p->ChannelImpl;
    %<(SLibCGCallSubFcn("c2wgnvw4uy", ["&d", "2"], 0, 18, 15))>;
    if (options_Parity->size[1] == 1) {
        success = d->size[0] * d->size[1];
        d->size[0] = 1;
        d->size[1] = 2;
        %<(SLibCGCallSubFcn("kt1e3yths5", ["d", "success"], 0, 18, 8))>;
        d->data[0] = options_Parity->data[0];
        d->data[1] = options_Parity->data[0];
    } else {
        success = d->size[0] * d->size[1];
        d->size[0] = 1;
        d->size[1] = options_Parity->size[1];
        %<(SLibCGCallSubFcn("kt1e3yths5", ["d", "success"], 0, 18, 7))>;
        loop_ub = options_Parity->size[1];
        if (loop_ub - 1 >= 0) {
            memcpy(&d->data[0], &options_Parity->data[0], (uint32_T)loop_ub * sizeof(char_T));
        }
    }
    if (options_FlowControl->size[1] == 1) {
        success = d_value->size[0] * d_value->size[1];
        d_value->size[0] = 1;
        d_value->size[1] = 2;
        %<(SLibCGCallSubFcn("kt1e3yths5", ["d_value", "success"], 0, 18, 11))>;
        d_value->data[0] = options_FlowControl->data[0];
        d_value->data[1] = options_FlowControl->data[0];
    } else {
        success = d_value->size[0] * d_value->size[1];
        d_value->size[0] = 1;
        d_value->size[1] = options_FlowControl->size[1];
        %<(SLibCGCallSubFcn("kt1e3yths5", ["d_value", "success"], 0, 18, 10))>;
        loop_ub = options_FlowControl->size[1];
        if (loop_ub - 1 >= 0) {
            memcpy(&d_value->data[0], &options_FlowControl->data[0], (uint32_T)loop_ub * sizeof(char_T));
        }
    }
    c[0] = out;
    c[1] = out;
    e[0] = out_p;
    e[1] = out_p;
    f[0] = out_e;
    f[1] = out_e;
    h[0] = options_IsWriteOnly;
    h[1] = options_IsWriteOnly;
    i[0] = options_IsSharingPort;
    i[1] = options_IsSharingPort;
    j[0] = options_IsSharingExistingTimeout;
    j[1] = options_IsSharingExistingTimeout;
    success = coderChannelOpen(chImpl, 9, "ServiceName", "char", 5, &b[0], "BaudRate", "double", 1, &c[0], "Parity", "char", options_Parity->size[1], &d->data[0], "StopBits", "double", 1, &e[0], "DataBits", "double", 1, &f[0], "FlowControl", "char", options_FlowControl->size[1], &d_value->data[0], "IsWriteOnly", "logical", 1, &h[0], "IsSharingPort", "logical", 1, &i[0], "IsSharingExistingTimeout", "logical", 1, &j[0]);
    %<(SLibCGCallSubFcn("ec2asd4d0o", ["&d"], 0, 18, 19))>;
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&options_FlowControl"], 0, 18, 18))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&options_Parity"], 0, 18, 17))>;
if (obj->IsSharingPort && (!obj->IsSharingExistingTimeout) && %<(SLibCGCallSubFcn("dyeylk2zzmj", ["obj"], 0, 18, 0))>) {
    out = %<(SLibCGCallSubFcn("lcng5t0i0zp", ["obj"], 0, 18, 3))>;
    %<(SLibCGCallSubFcn("nokkyn0chrz", ["obj"], 0, 18, 4))>;
    obj_p = obj->AsyncIOChannel;
    chImpl = obj_p->ChannelImpl;
    c[0] = out;
    c[1] = out;
    success = coderChannelExecute(chImpl, "SetSharedTimeout", 1, "SharedTimeout", "double", 1, &c[0]);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
%<(SLibCGCallSubFcn("lcng5t0i0zp", ["obj"], 0, 18, 2))>;
success = d_value->size[0] * d_value->size[1];
d_value->size[0] = 1;
d_value->size[1] = obj->ByteOrder->size[1];
%<(SLibCGCallSubFcn("kt1e3yths5", ["d_value", "success"], 0, 18, 9))>;
loop_ub = obj->ByteOrder->size[1];
for (success = 0; success < loop_ub; success++) {
    d_value->data[success] = obj->ByteOrder->data[success];
}
obj_e = obj->TransportChannel;
if (%<(SLibCGCallSubFcn("l1feuv03fpleou", ["d_value", "(real_T)d_value->size[1]"], 0, 18, 1))>) {
    loop_ub = 13;
    for (success = 0; success < 13; success++) {
        b_value_data[success] = tmp[success];
    }
} else {
    loop_ub = 10;
    for (success = 0; success < 10; success++) {
        b_value_data[success] = b_b[success];
    }
}
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&d_value"], 0, 18, 20))>;
success = obj_e->ByteOrder->size[0] * obj_e->ByteOrder->size[1];
obj_e->ByteOrder->size[0] = 1;
obj_e->ByteOrder->size[1] = 0;
obj_e->ByteOrder->size[0] = 1;
obj_e->ByteOrder->size[1] = loop_ub;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj_e->ByteOrder", "success"], 0, 18, 12))>;
loop_ub--;
for (success = 0; success <= loop_ub; success++) {
    obj_e->ByteOrder->data[success] = b_value_data[success];
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void ltdh5g0hxx(\
%assign comma = ""
%<comma>fops2f5bc43 *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 18, fcnProtoType)>
%return fcnBuff
%endfunction

%function pmpprwcsr4p_Fcn19(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
afxtk4erg3r *obj_p;
habembxjygt *obj_e;
hgyzgm1py1 *out;
real_T b[2];
int32_T loop_ub;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
char_T b_p[4];
boolean_T hasSyncError;
static const char_T tmp[5] = %<(TLC_STR_CTX(9))>;
static const char_T tmp_p[13] = %<(TLC_STR_CTX(10))>;
static const char_T tmp_e[5] = %<(TLC_STR_CTX(11))>;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,19,14,0)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,19,13,0)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,19,12,0)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,19,9,0)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,19,8,0)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,19,7,0)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,19,7,1)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,19,7,2)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,19,6,0)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,19,5,0)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,19,4,0)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,19,3,0)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,19,2,0)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,19,1,0)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,19,0,0)
%<SLibCG_AccessArg(0 ,19, 0)>
%endif

obj->isSetupComplete = false;
obj->isInitialized = 1;
obj->SerialObj.IsSharingPort = false;
obj->SerialObj.IsSharingExistingTimeout = false;
obj->SerialObj.Timeout = 10.0;
obj->SerialObj.InputBufferSize = %<LibGetMathConstant(LibRealNonFinite("inf"), FcnGetDataTypeIdFromName("double"))>;
obj->SerialObj.OutputBufferSize = %<LibGetMathConstant(LibRealNonFinite("inf"), FcnGetDataTypeIdFromName("double"))>;
for (success = 0; success < 5; success++) {
    obj->SerialObj.Port[success] = tmp[success];
}
%<(SLibCGCallSubFcn("kh2gvvgen0t", ["&obj->SerialObj", "&obj->SerialObj._pobj0", "&obj->SerialObj._pobj1"], 0, 19, 7))>;
if (%<(SLibCGCallSubFcn("o4wczq2e3h0", ["&obj->SerialObj"], 0, 19, 0))>) {
    obj_p = obj->SerialObj.AsyncIOChannel;
    chImpl = obj_p->ChannelImpl;
    b[0] = 115200.0;
    b[1] = 115200.0;
    success = coderChannelExecute(chImpl, "SetBaudRate", 1, "BaudRate", "double", 1, &b[0]);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
obj->SerialObj.BaudRate = 115200.0;
if (%<(SLibCGCallSubFcn("o4wczq2e3h0", ["&obj->SerialObj"], 0, 19, 1))>) {
    obj_p = obj->SerialObj.AsyncIOChannel;
    chImpl = obj_p->ChannelImpl;
    b[0] = 8.0;
    b[1] = 8.0;
    success = coderChannelExecute(chImpl, "SetDataBits", 1, "DataBits", "double", 1, &b[0]);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
obj->SerialObj.DataBits = 8.0;
if (%<(SLibCGCallSubFcn("o4wczq2e3h0", ["&obj->SerialObj"], 0, 19, 2))>) {
    obj_p = obj->SerialObj.AsyncIOChannel;
    chImpl = obj_p->ChannelImpl;
    b_p[0] = 'n';
    b_p[1] = 'o';
    b_p[2] = 'n';
    b_p[3] = 'e';
    success = coderChannelExecute(chImpl, "SetParity", 1, "Parity", "char", 4, &b_p[0]);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
success = obj->SerialObj.Parity->size[0] * obj->SerialObj.Parity->size[1];
obj->SerialObj.Parity->size[0] = 1;
obj->SerialObj.Parity->size[1] = 0;
obj->SerialObj.Parity->size[0] = 1;
obj->SerialObj.Parity->size[1] = 4;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj->SerialObj.Parity", "success"], 0, 19, 8))>;
obj->SerialObj.Parity->data[0] = 'n';
obj->SerialObj.Parity->data[1] = 'o';
obj->SerialObj.Parity->data[2] = 'n';
obj->SerialObj.Parity->data[3] = 'e';
if (%<(SLibCGCallSubFcn("o4wczq2e3h0", ["&obj->SerialObj"], 0, 19, 3))>) {
    obj_p = obj->SerialObj.AsyncIOChannel;
    chImpl = obj_p->ChannelImpl;
    b[0] = 1.0;
    b[1] = 1.0;
    success = coderChannelExecute(chImpl, "SetStopBits", 1, "StopBits", "double", 1, &b[0]);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
obj->SerialObj.StopBits = 1.0;
if (%<(SLibCGCallSubFcn("o4wczq2e3h0", ["&obj->SerialObj"], 0, 19, 4))>) {
    obj_p = obj->SerialObj.AsyncIOChannel;
    chImpl = obj_p->ChannelImpl;
    b_p[0] = 'n';
    b_p[1] = 'o';
    b_p[2] = 'n';
    b_p[3] = 'e';
    success = coderChannelExecute(chImpl, "SetFlowControl", 1, "FlowControl", "char", 4, &b_p[0]);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
success = obj->SerialObj.FlowControl->size[0] * obj->SerialObj.FlowControl->size[1];
obj->SerialObj.FlowControl->size[0] = 1;
obj->SerialObj.FlowControl->size[1] = 0;
obj->SerialObj.FlowControl->size[0] = 1;
obj->SerialObj.FlowControl->size[1] = 4;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj->SerialObj.FlowControl", "success"], 0, 19, 9))>;
obj->SerialObj.FlowControl->data[0] = 'n';
obj->SerialObj.FlowControl->data[1] = 'o';
obj->SerialObj.FlowControl->data[2] = 'n';
obj->SerialObj.FlowControl->data[3] = 'e';
obj_e = obj->SerialObj.TransportChannel;
success = obj_e->ByteOrder->size[0] * obj_e->ByteOrder->size[1];
obj_e->ByteOrder->size[0] = 1;
obj_e->ByteOrder->size[1] = 0;
obj_e->ByteOrder->size[0] = 1;
obj_e->ByteOrder->size[1] = 13;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj_e->ByteOrder", "success"], 0, 19, 10))>;
for (success = 0; success < 13; success++) {
    obj_e->ByteOrder->data[success] = tmp_p[success];
}
obj->SerialObj.ByteOrder->size[0] = 1;
obj->SerialObj.ByteOrder->size[1] = 0;
obj_e = obj->SerialObj.TransportChannel;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&out", "2"], 0, 19, 15))>;
success = out->size[0] * out->size[1];
out->size[0] = 1;
out->size[1] = obj_e->ByteOrder->size[1];
%<(SLibCGCallSubFcn("kt1e3yths5", ["out", "success"], 0, 19, 11))>;
loop_ub = obj_e->ByteOrder->size[1];
for (success = 0; success < loop_ub; success++) {
    out->data[success] = obj_e->ByteOrder->data[success];
}
success = obj->SerialObj.ByteOrder->size[0] * obj->SerialObj.ByteOrder->size[1];
obj->SerialObj.ByteOrder->size[0] = 1;
obj->SerialObj.ByteOrder->size[1] = out->size[1];
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj->SerialObj.ByteOrder", "success"], 0, 19, 12))>;
loop_ub = out->size[1] - 1;
for (success = 0; success <= loop_ub; success++) {
    obj->SerialObj.ByteOrder->data[success] = out->data[success];
}
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&out"], 0, 19, 16))>;
if (!obj->SerialObj.IsSharingExistingTimeout) {
    obj->SerialObj.Timeout = 1.0;
}
obj->SerialObj.IsWriteOnly = true;
obj->SerialObj.IsSharingPort = true;
obj->SerialObj.IsSharingExistingTimeout = false;
success = obj->SerialObj.NativeDataType->size[0] * obj->SerialObj.NativeDataType->size[1];
obj->SerialObj.NativeDataType->size[0] = 1;
obj->SerialObj.NativeDataType->size[1] = 0;
obj->SerialObj.NativeDataType->size[0] = 1;
obj->SerialObj.NativeDataType->size[1] = 5;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj->SerialObj.NativeDataType", "success"], 0, 19, 13))>;
for (success = 0; success < 5; success++) {
    obj->SerialObj.NativeDataType->data[success] = tmp_e[success];
}
success = obj->SerialObj.DataFieldName->size[0] * obj->SerialObj.DataFieldName->size[1];
obj->SerialObj.DataFieldName->size[0] = 1;
obj->SerialObj.DataFieldName->size[1] = 0;
obj->SerialObj.DataFieldName->size[0] = 1;
obj->SerialObj.DataFieldName->size[1] = 4;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj->SerialObj.DataFieldName", "success"], 0, 19, 14))>;
obj->SerialObj.DataFieldName->data[0] = 'D';
obj->SerialObj.DataFieldName->data[1] = 'a';
obj->SerialObj.DataFieldName->data[2] = 't';
obj->SerialObj.DataFieldName->data[3] = 'a';
obj->SerialObj.matlabCodegenIsDeleted = false;
%<(SLibCGCallSubFcn("ltdh5g0hxx", ["&obj->SerialObj"], 0, 19, 5))>;
%<(SLibCGCallSubFcn("dyeylk2zzmj", ["&obj->SerialObj"], 0, 19, 6))>;
obj->isSetupComplete = true;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void pmpprwcsr4p(\
%assign comma = ""
%<comma>evr2nhlpli *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 19, fcnProtoType)>
%return fcnBuff
%endfunction

%function gilqgzxw0nx_Fcn20(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,20,1,0)
%<SLibCG_AccessArg(0 ,20, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,20,0,0)
%<SLibCG_AccessArg(0 ,20, 0)>
%endif

%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&pStruct->PartialPacket", "2"], 0, 20, 0))>;
%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&pStruct->ExampleData", "2"], 0, 20, 1))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void gilqgzxw0nx(\
%assign comma = ""
%<comma>i0lstc3zfv *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 20, fcnProtoType)>
%return fcnBuff
%endfunction

%function ctyecsexru4t_Fcn21(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,21,1,0)
%<SLibCG_AccessArg(0 ,21, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,21,0,0)
%<SLibCG_AccessArg(0 ,21, 0)>
%endif

%<(SLibCGCallSubFcn("gilqgzxw0nx", ["&pStruct->InputStream"], 0, 21, 0))>;
%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&pStruct->PartialPacket", "2"], 0, 21, 1))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void ctyecsexru4t(\
%assign comma = ""
%<comma>kw1nls53yo *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 21, fcnProtoType)>
%return fcnBuff
%endfunction

%function aoooaxuzdi1_Fcn22(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,22,3,0)
%<SLibCG_AccessArg(0 ,22, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,22,2,0)
%<SLibCG_AccessArg(0 ,22, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,22,1,0)
%<SLibCG_AccessArg(0 ,22, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,22,0,0)
%<SLibCG_AccessArg(0 ,22, 0)>
%endif

%<(SLibCGCallSubFcn("ctyecsexru4t", ["&pStruct->UnreadDataBuffer"], 0, 22, 0))>;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&pStruct->ByteOrder", "2"], 0, 22, 1))>;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&pStruct->NativeDataType", "2"], 0, 22, 2))>;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&pStruct->DataFieldName", "2"], 0, 22, 3))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void aoooaxuzdi1(\
%assign comma = ""
%<comma>habembxjyg *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 22, fcnProtoType)>
%return fcnBuff
%endfunction

%function ctyecsexru4ts_Fcn23(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,23,0,0)
%<SLibCG_AccessArg(0 ,23, 0)>
%endif

%<(SLibCGCallSubFcn("gilqgzxw0nx", ["&pStruct->InputStream"], 0, 23, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void ctyecsexru4ts(\
%assign comma = ""
%<comma>afxtk4erg3 *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 23, fcnProtoType)>
%return fcnBuff
%endfunction

%function dvff4meo5cp_Fcn24(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,24,6,0)
%<SLibCG_AccessArg(0 ,24, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,24,5,0)
%<SLibCG_AccessArg(0 ,24, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,24,4,0)
%<SLibCG_AccessArg(0 ,24, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,24,3,0)
%<SLibCG_AccessArg(0 ,24, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,24,2,0)
%<SLibCG_AccessArg(0 ,24, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,24,1,0)
%<SLibCG_AccessArg(0 ,24, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,24,0,0)
%<SLibCG_AccessArg(0 ,24, 0)>
%endif

%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&pStruct->ByteOrder", "2"], 0, 24, 0))>;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&pStruct->NativeDataType", "2"], 0, 24, 1))>;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&pStruct->DataFieldName", "2"], 0, 24, 2))>;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&pStruct->FlowControl", "2"], 0, 24, 3))>;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&pStruct->Parity", "2"], 0, 24, 4))>;
%<(SLibCGCallSubFcn("aoooaxuzdi1", ["&pStruct->_pobj0"], 0, 24, 5))>;
%<(SLibCGCallSubFcn("ctyecsexru4ts", ["&pStruct->_pobj1"], 0, 24, 6))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void dvff4meo5cp(\
%assign comma = ""
%<comma>fops2f5bc4 *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 24, fcnProtoType)>
%return fcnBuff
%endfunction

%function hw3nft2agy_Fcn25(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,25,0,0)
%<SLibCG_AccessArg(0 ,25, 0)>
%endif

%<(SLibCGCallSubFcn("dvff4meo5cp", ["&pStruct->SerialObj"], 0, 25, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void hw3nft2agy(\
%assign comma = ""
%<comma>pry1oxlo21 *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 25, fcnProtoType)>
%return fcnBuff
%endfunction

%function lv0yfzd1c2_Fcn26(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
if (*pEmxArray != (ftbvbe5nvy *)NULL) {
    if (((*pEmxArray)->data != (uint8_T *)NULL) && (*pEmxArray)->canFreeData) {
        free((*pEmxArray)->data);
    }
    free((*pEmxArray)->size);
    free(*pEmxArray);
    *pEmxArray = (ftbvbe5nvy *)NULL;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void lv0yfzd1c2(\
%assign comma = ""
%<comma>ftbvbe5nvy **pEmxArray\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 26, fcnProtoType)>
%return fcnBuff
%endfunction

%function duuwt0luct_Fcn27(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderInputStream streamImpl;
ftbvbe5nvy *exampleData;
i0lstc3zfv *b_obj;
int32_T tmp;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,27,0,0)
%<SLibCG_AccessArg(0 ,27, 0)>
%endif

obj->Timeout = 10.0;
b_obj = obj;
streamImpl = coderChannelGetInputStream(channelImpl);
obj->StreamImpl = streamImpl;
tmp = obj->ExampleData->size[0] * obj->ExampleData->size[1];
obj->ExampleData->size[0] = 1;
obj->ExampleData->size[1] = 1;
%<(SLibCGCallSubFcn("fptaaqsn5k", ["obj->ExampleData", "tmp"], 0, 27, 0))>;
obj->ExampleData->data[0] = 0U;
%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&exampleData", "2"], 0, 27, 2))>;
tmp = exampleData->size[0] * exampleData->size[1];
exampleData->size[0] = obj->ExampleData->size[0];
%<(SLibCGCallSubFcn("fptaaqsn5k", ["exampleData", "tmp"], 0, 27, 1))>;
obj->PartialPacket->size[0] = exampleData->size[0];
%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&exampleData"], 0, 27, 3))>;
obj->PartialPacket->size[1] = 0;
obj->PartialPacketStart = 0.0;
obj->PartialPacketCount = 0.0;
obj->matlabCodegenIsDeleted = false;
return b_obj;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static i0lstc3zfv *duuwt0luct(\
%assign comma = ""
%<comma>i0lstc3zfv *obj\
%assign comma = ", "
%<comma>CoderChannel channelImpl\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 27, fcnProtoType)>
%return fcnBuff
%endfunction

%function nokkyn0chr_Fcn28(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
afxtk4erg3 *obj_p;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T hasSyncError;
obj_p = obj->AsyncIOChannel;
chImpl = obj_p->ChannelImpl;
success = coderChannelIsOpen(chImpl, &hasSyncError);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void nokkyn0chr(\
%assign comma = ""
%<comma>fops2f5bc4 *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 28, fcnProtoType)>
%return fcnBuff
%endfunction

%function lcng5t0i0z_Fcn29(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
afxtk4erg3 *obj_p;
real_T b_value;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T hasSyncError;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,29,0,0)
%<SLibCG_AccessArg(0 ,29, 0)>
%endif

if (!obj->IsSharingExistingTimeout) {
    b_value = obj->Timeout;
} else {
    %<(SLibCGCallSubFcn("nokkyn0chr", ["obj"], 0, 29, 0))>;
    obj_p = obj->AsyncIOChannel;
    chImpl = obj_p->ChannelImpl;
    success = coderChannelExecute(chImpl, "GetSharedTimeout", 0);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
    obj_p = obj->AsyncIOChannel;
    b_value = obj_p->CustomProps.SharedTimeout;
    chImpl = obj_p->ChannelImpl;
    success = coderChannelGetPropertyValue(chImpl, "SharedTimeout", "double", 1, &b_value);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
return b_value;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static real_T lcng5t0i0z(\
%assign comma = ""
%<comma>fops2f5bc4 *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 29, fcnProtoType)>
%return fcnBuff
%endfunction

%function kh2gvvgen0_Fcn30(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
CoderOutputStream streamImpl;
afxtk4erg3 *channel;
clvl5hd3q0 *outputStream;
habembxjyg *obj_p;
i0lstc3zfv *inputStream;
real_T e[2];
real_T f[2];
real_T varargin_8[2];
real_T b_value;
int32_T success;
char_T converterPlugin_data[4096];
char_T deviceFullPath_data[4096];
char_T devicePath_data[4096];
char_T devicePlugin_data[4096];
char_T localAbsPath[4096];
char_T errorID[1024];
char_T errorText[1024];
char_T b[5];
char_T d[4];
char_T g[4];
boolean_T hasSyncError;
boolean_T result;
static const char_T tmp[13] = %<(TLC_STR_CTX(12))>;
static const char_T tmp_p[5] = %<(TLC_STR_CTX(13))>;
int32_T deviceFullPath_size[2];
int32_T converterPlugin_size_idx_1;
int32_T devicePath_size_idx_1;
int32_T devicePlugin_size_idx_1;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,30,11,0)
%<SLibCG_AccessArg(0 ,30, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,30,10,0)
%<SLibCG_AccessArg(0 ,30, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,30,9,0)
%<SLibCG_AccessArg(0 ,30, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,30,8,0)
%<SLibCG_AccessArg(0 ,30, 1)>
%endif
%if SLibCG_FcnCallArgAccessed(0,30,8,1)
%<SLibCG_AccessArg(0 ,30, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,30,5,0)
%<SLibCG_AccessArg(0 ,30, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,30,4,0)
%<SLibCG_AccessArg(0 ,30, 2)>
%endif
%if SLibCG_FcnCallArgAccessed(0,30,4,1)
%<SLibCG_AccessArg(0 ,30, 2)>
%endif

for (success = 0; success < 5; success++) {
    b[success] = obj->Port[success];
}
coderComputeAbsolutePath("serialdevice.dll", &localAbsPath[0]);
%<(SLibCGCallSubFcn("kjimvvt0ge", ["localAbsPath", "deviceFullPath_data", "deviceFullPath_size"], 0, 30, 0))>;
if (deviceFullPath_size[1] != 0) {
    devicePlugin_size_idx_1 = deviceFullPath_size[1];
    success = deviceFullPath_size[1];
    memcpy(&devicePlugin_data[0], &deviceFullPath_data[0], (uint32_T)success * sizeof(char_T));
} else {
    coderComputeAbsolutePath("%<TLC_STR_CTX(14)>", &localAbsPath[0]);
    %<(SLibCGCallSubFcn("kjimvvt0ge", ["localAbsPath", "deviceFullPath_data", "deviceFullPath_size"], 0, 30, 1))>;
    if (deviceFullPath_size[1] != 0) {
        devicePlugin_size_idx_1 = deviceFullPath_size[1];
        success = deviceFullPath_size[1];
        memcpy(&devicePlugin_data[0], &deviceFullPath_data[0], (uint32_T)success * sizeof(char_T));
    }
}
coderComputeAbsolutePath("serialcoderconverter.dll", &localAbsPath[0]);
%<(SLibCGCallSubFcn("kjimvvt0ge", ["localAbsPath", "deviceFullPath_data", "deviceFullPath_size"], 0, 30, 2))>;
if (deviceFullPath_size[1] != 0) {
    converterPlugin_size_idx_1 = deviceFullPath_size[1];
    success = deviceFullPath_size[1];
    memcpy(&converterPlugin_data[0], &deviceFullPath_data[0], (uint32_T)success * sizeof(char_T));
} else {
    coderComputeAbsolutePath("%<TLC_STR_CTX(15)>", &localAbsPath[0]);
    %<(SLibCGCallSubFcn("kjimvvt0ge", ["localAbsPath", "deviceFullPath_data", "deviceFullPath_size"], 0, 30, 3))>;
    if (deviceFullPath_size[1] != 0) {
        converterPlugin_size_idx_1 = deviceFullPath_size[1];
        success = deviceFullPath_size[1];
        memcpy(&converterPlugin_data[0], &deviceFullPath_data[0], (uint32_T)success * sizeof(char_T));
    }
}
varargin_8[0] = obj->InputBufferSize;
varargin_8[1] = obj->OutputBufferSize;
iobj_1->CustomProps.CTS = true;
iobj_1->CustomProps.DSR = true;
iobj_1->CustomProps.CD = true;
iobj_1->CustomProps.RING = true;
iobj_1->CustomProps.InitAccess = true;
iobj_1->CustomProps.SharedTimeout = 0.0;
iobj_1->CustomProps.LatestNumBytesWrittenToDevice = 0ULL;
iobj_1->CustomProps.TotalBytesWritten = 0ULL;
iobj_1->ChannelImpl = 0;
memcpy(&rtB.b_devicePluginPath_data[0], &devicePlugin_data[0], (uint32_T)devicePlugin_size_idx_1 * sizeof(char_T));
rtB.b_devicePluginPath_data[devicePlugin_size_idx_1] = '\x00';
memcpy(&rtB.b_converterPluginPath_data[0], &converterPlugin_data[0], (uint32_T)converterPlugin_size_idx_1 * sizeof(char_T));
rtB.b_converterPluginPath_data[converterPlugin_size_idx_1] = '\x00';
chImpl = coderChannelCreate(&rtB.b_devicePluginPath_data[0], &rtB.b_converterPluginPath_data[0], varargin_8[0], varargin_8[1], &errorID[0], &errorText[0]);
iobj_1->ChannelImpl = chImpl;
chImpl = iobj_1->ChannelImpl;
varargin_8[0] = 9600.0;
varargin_8[1] = 9600.0;
d[0] = 'n';
d[1] = 'o';
d[2] = 'n';
d[3] = 'e';
e[0] = 1.0;
f[0] = 8.0;
e[1] = 1.0;
f[1] = 8.0;
g[0] = 'n';
g[1] = 'o';
g[2] = 'n';
g[3] = 'e';
success = coderChannelInit(chImpl, 6, "ServiceName", "char", 5, &b[0], "BaudRate", "double", 1, &varargin_8[0], "Parity", "char", 4, &d[0], "StopBits", "double", 1, &e[0], "DataBits", "double", 1, &f[0], "FlowControl", "char", 4, &g[0]);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
%<(SLibCGCallSubFcn("duuwt0luct", ["&iobj_1->InputStream", "iobj_1->ChannelImpl"], 0, 30, 4))>;
chImpl = iobj_1->ChannelImpl;
iobj_1->OutputStream.Timeout = 10.0;
streamImpl = coderChannelGetOutputStream(chImpl);
iobj_1->OutputStream.StreamImpl = streamImpl;
iobj_1->OutputStream.matlabCodegenIsDeleted = false;
iobj_1->matlabCodegenIsDeleted = false;
obj->AsyncIOChannel = iobj_1;
if ((!obj->IsSharingPort) || (!obj->IsSharingExistingTimeout)) {
    b_value = %<(SLibCGCallSubFcn("lcng5t0i0z", ["obj"], 0, 30, 5))>;
    outputStream = &obj->AsyncIOChannel->OutputStream;
    inputStream = &obj->AsyncIOChannel->InputStream;
    outputStream->Timeout = b_value;
    inputStream->Timeout = b_value;
}
channel = obj->AsyncIOChannel;
iobj_0->AllowPartialReads = false;
for (success = 0; success < 13; success++) {
    iobj_0->MachineByteOrder[success] = tmp[success];
}
iobj_0->AsyncIOChannel = channel;
success = iobj_0->ByteOrder->size[0] * iobj_0->ByteOrder->size[1];
iobj_0->ByteOrder->size[0] = 1;
iobj_0->ByteOrder->size[1] = 0;
iobj_0->ByteOrder->size[0] = 1;
iobj_0->ByteOrder->size[1] = 13;
%<(SLibCGCallSubFcn("kt1e3yths5", ["iobj_0->ByteOrder", "success"], 0, 30, 9))>;
for (success = 0; success < 13; success++) {
    iobj_0->ByteOrder->data[success] = tmp[success];
}
success = iobj_0->DataFieldName->size[0] * iobj_0->DataFieldName->size[1];
iobj_0->DataFieldName->size[0] = 1;
iobj_0->DataFieldName->size[1] = 0;
iobj_0->DataFieldName->size[0] = 1;
iobj_0->DataFieldName->size[1] = 4;
%<(SLibCGCallSubFcn("kt1e3yths5", ["iobj_0->DataFieldName", "success"], 0, 30, 10))>;
iobj_0->DataFieldName->data[0] = 'D';
iobj_0->DataFieldName->data[1] = 'a';
iobj_0->DataFieldName->data[2] = 't';
iobj_0->DataFieldName->data[3] = 'a';
success = iobj_0->NativeDataType->size[0] * iobj_0->NativeDataType->size[1];
iobj_0->NativeDataType->size[0] = 1;
iobj_0->NativeDataType->size[1] = 0;
iobj_0->NativeDataType->size[0] = 1;
iobj_0->NativeDataType->size[1] = 5;
%<(SLibCGCallSubFcn("kt1e3yths5", ["iobj_0->NativeDataType", "success"], 0, 30, 11))>;
for (success = 0; success < 5; success++) {
    iobj_0->NativeDataType->data[success] = tmp_p[success];
}
iobj_0->UnreadDataBuffer.BytesPerElement = 1.0;
coderComputeAbsolutePath("buffer.dll", &localAbsPath[0]);
%<(SLibCGCallSubFcn("kjimvvt0ge", ["localAbsPath", "deviceFullPath_data", "deviceFullPath_size"], 0, 30, 6))>;
if (deviceFullPath_size[1] != 0) {
    devicePath_size_idx_1 = deviceFullPath_size[1];
    success = deviceFullPath_size[1];
    memcpy(&devicePath_data[0], &deviceFullPath_data[0], (uint32_T)success * sizeof(char_T));
} else {
    coderComputeAbsolutePath("%<TLC_STR_CTX(16)>", &localAbsPath[0]);
    %<(SLibCGCallSubFcn("kjimvvt0ge", ["localAbsPath", "deviceFullPath_data", "deviceFullPath_size"], 0, 30, 7))>;
    if (deviceFullPath_size[1] != 0) {
        devicePath_size_idx_1 = deviceFullPath_size[1];
        success = deviceFullPath_size[1];
        memcpy(&devicePath_data[0], &deviceFullPath_data[0], (uint32_T)success * sizeof(char_T));
    }
}
iobj_0->UnreadDataBuffer.ChannelImpl = 0;
memcpy(&rtB.b_devicePluginPath_data[0], &devicePath_data[0], (uint32_T)devicePath_size_idx_1 * sizeof(char_T));
rtB.b_devicePluginPath_data[devicePath_size_idx_1] = '\x00';
chImpl = coderChannelCreate(&rtB.b_devicePluginPath_data[0], "%<TLC_STR_CTX(17)>", %<LibGetMathConstant(LibRealNonFinite("inf"), FcnGetDataTypeIdFromName("double"))>, 0.0, &errorID[0], &errorText[0]);
iobj_0->UnreadDataBuffer.ChannelImpl = chImpl;
chImpl = iobj_0->UnreadDataBuffer.ChannelImpl;
success = coderChannelInit(chImpl, 0);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
%<(SLibCGCallSubFcn("duuwt0luct", ["&iobj_0->UnreadDataBuffer.InputStream", "iobj_0->UnreadDataBuffer.ChannelImpl"], 0, 30, 8))>;
chImpl = iobj_0->UnreadDataBuffer.ChannelImpl;
iobj_0->UnreadDataBuffer.OutputStream.Timeout = 10.0;
streamImpl = coderChannelGetOutputStream(chImpl);
iobj_0->UnreadDataBuffer.OutputStream.StreamImpl = streamImpl;
iobj_0->UnreadDataBuffer.OutputStream.matlabCodegenIsDeleted = false;
iobj_0->UnreadDataBuffer.TotalElementsWritten = 0.0;
iobj_0->UnreadDataBuffer.PartialPacket->size[0] = 1;
iobj_0->UnreadDataBuffer.PartialPacket->size[1] = 0;
iobj_0->UnreadDataBuffer.PartialPacket->size[0] = 0;
iobj_0->UnreadDataBuffer.PartialPacket->size[1] = 0;
iobj_0->UnreadDataBuffer.PartialPacketStart = 0.0;
iobj_0->UnreadDataBuffer.PartialPacketCount = 0.0;
iobj_0->UnreadDataBuffer.matlabCodegenIsDeleted = false;
chImpl = iobj_0->UnreadDataBuffer.ChannelImpl;
success = coderChannelIsOpen(chImpl, &result);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
if (!result) {
    chImpl = iobj_0->UnreadDataBuffer.ChannelImpl;
    success = coderChannelOpen(chImpl, 0);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
iobj_0->matlabCodegenIsDeleted = false;
obj->TransportChannel = iobj_0;
obj_p = obj->TransportChannel;
success = obj_p->ByteOrder->size[0] * obj_p->ByteOrder->size[1];
obj_p->ByteOrder->size[0] = 1;
obj_p->ByteOrder->size[1] = 0;
obj_p->ByteOrder->size[0] = 1;
obj_p->ByteOrder->size[1] = 13;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj_p->ByteOrder", "success"], 0, 30, 12))>;
for (success = 0; success < 13; success++) {
    obj_p->ByteOrder->data[success] = tmp[success];
}
obj_p = obj->TransportChannel;
success = obj_p->NativeDataType->size[0] * obj_p->NativeDataType->size[1];
obj_p->NativeDataType->size[0] = 1;
obj_p->NativeDataType->size[1] = 0;
obj_p->NativeDataType->size[0] = 1;
obj_p->NativeDataType->size[1] = 5;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj_p->NativeDataType", "success"], 0, 30, 13))>;
for (success = 0; success < 5; success++) {
    obj_p->NativeDataType->data[success] = tmp_p[success];
}
obj_p = obj->TransportChannel;
success = obj_p->DataFieldName->size[0] * obj_p->DataFieldName->size[1];
obj_p->DataFieldName->size[0] = 1;
obj_p->DataFieldName->size[1] = 0;
obj_p->DataFieldName->size[0] = 1;
obj_p->DataFieldName->size[1] = 4;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj_p->DataFieldName", "success"], 0, 30, 14))>;
obj_p->DataFieldName->data[0] = 'D';
obj_p->DataFieldName->data[1] = 'a';
obj_p->DataFieldName->data[2] = 't';
obj_p->DataFieldName->data[3] = 'a';
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void kh2gvvgen0(\
%assign comma = ""
%<comma>fops2f5bc4 *obj\
%assign comma = ", "
%<comma>habembxjyg *iobj_0\
%assign comma = ", "
%<comma>afxtk4erg3 *iobj_1\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 30, fcnProtoType)>
%return fcnBuff
%endfunction

%function o4wczq2e3h_Fcn31(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
afxtk4erg3 *obj_p;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T b_value;
boolean_T hasSyncError;
obj_p = obj->AsyncIOChannel;
chImpl = obj_p->ChannelImpl;
success = coderChannelIsOpen(chImpl, &b_value);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
return b_value;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static boolean_T o4wczq2e3h(\
%assign comma = ""
%<comma>fops2f5bc4 *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 31, fcnProtoType)>
%return fcnBuff
%endfunction

%function p5lbt2unbb_Fcn32(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
afxtk4erg3 *obj_p;
clvl5hd3q0 *outputStream;
fops2f5bc4 *b_obj;
habembxjyg *obj_e;
hgyzgm1py1 *out;
i0lstc3zfv *inputStream;
real_T b[2];
int32_T loop_ub;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
char_T b_p[4];
boolean_T hasSyncError;
static const char_T tmp[5] = %<(TLC_STR_CTX(18))>;
static const char_T tmp_p[13] = %<(TLC_STR_CTX(19))>;
static const char_T tmp_e[5] = %<(TLC_STR_CTX(20))>;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,32,13,0)
%<SLibCG_AccessArg(0 ,32, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,32,11,0)
%<SLibCG_AccessArg(0 ,32, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,32,10,0)
%<SLibCG_AccessArg(0 ,32, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,32,7,0)
%<SLibCG_AccessArg(0 ,32, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,32,6,0)
%<SLibCG_AccessArg(0 ,32, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,32,5,0)
%<SLibCG_AccessArg(0 ,32, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,32,5,1)
%<SLibCG_AccessArg(0 ,32, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,32,5,2)
%<SLibCG_AccessArg(0 ,32, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,32,4,0)
%<SLibCG_AccessArg(0 ,32, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,32,3,0)
%<SLibCG_AccessArg(0 ,32, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,32,2,0)
%<SLibCG_AccessArg(0 ,32, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,32,1,0)
%<SLibCG_AccessArg(0 ,32, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,32,0,0)
%<SLibCG_AccessArg(0 ,32, 0)>
%endif

obj->IsSharingPort = false;
obj->IsSharingExistingTimeout = false;
obj->Timeout = 10.0;
obj->InputBufferSize = %<LibGetMathConstant(LibRealNonFinite("inf"), FcnGetDataTypeIdFromName("double"))>;
obj->OutputBufferSize = %<LibGetMathConstant(LibRealNonFinite("inf"), FcnGetDataTypeIdFromName("double"))>;
b_obj = obj;
for (success = 0; success < 5; success++) {
    obj->Port[success] = tmp[success];
}
%<(SLibCGCallSubFcn("kh2gvvgen0", ["obj", "&obj->_pobj0", "&obj->_pobj1"], 0, 32, 5))>;
if (%<(SLibCGCallSubFcn("o4wczq2e3h", ["obj"], 0, 32, 0))>) {
    obj_p = obj->AsyncIOChannel;
    chImpl = obj_p->ChannelImpl;
    b[0] = 9600.0;
    b[1] = 9600.0;
    success = coderChannelExecute(chImpl, "SetBaudRate", 1, "BaudRate", "double", 1, &b[0]);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
obj->BaudRate = 9600.0;
if (%<(SLibCGCallSubFcn("o4wczq2e3h", ["obj"], 0, 32, 1))>) {
    obj_p = obj->AsyncIOChannel;
    chImpl = obj_p->ChannelImpl;
    b[0] = 8.0;
    b[1] = 8.0;
    success = coderChannelExecute(chImpl, "SetDataBits", 1, "DataBits", "double", 1, &b[0]);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
obj->DataBits = 8.0;
if (%<(SLibCGCallSubFcn("o4wczq2e3h", ["obj"], 0, 32, 2))>) {
    obj_p = obj->AsyncIOChannel;
    chImpl = obj_p->ChannelImpl;
    b_p[0] = 'n';
    b_p[1] = 'o';
    b_p[2] = 'n';
    b_p[3] = 'e';
    success = coderChannelExecute(chImpl, "SetParity", 1, "Parity", "char", 4, &b_p[0]);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
success = obj->Parity->size[0] * obj->Parity->size[1];
obj->Parity->size[0] = 1;
obj->Parity->size[1] = 0;
obj->Parity->size[0] = 1;
obj->Parity->size[1] = 4;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj->Parity", "success"], 0, 32, 6))>;
obj->Parity->data[0] = 'n';
obj->Parity->data[1] = 'o';
obj->Parity->data[2] = 'n';
obj->Parity->data[3] = 'e';
if (%<(SLibCGCallSubFcn("o4wczq2e3h", ["obj"], 0, 32, 3))>) {
    obj_p = obj->AsyncIOChannel;
    chImpl = obj_p->ChannelImpl;
    b[0] = 1.0;
    b[1] = 1.0;
    success = coderChannelExecute(chImpl, "SetStopBits", 1, "StopBits", "double", 1, &b[0]);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
obj->StopBits = 1.0;
if (%<(SLibCGCallSubFcn("o4wczq2e3h", ["obj"], 0, 32, 4))>) {
    obj_p = obj->AsyncIOChannel;
    chImpl = obj_p->ChannelImpl;
    b_p[0] = 'n';
    b_p[1] = 'o';
    b_p[2] = 'n';
    b_p[3] = 'e';
    success = coderChannelExecute(chImpl, "SetFlowControl", 1, "FlowControl", "char", 4, &b_p[0]);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
success = obj->FlowControl->size[0] * obj->FlowControl->size[1];
obj->FlowControl->size[0] = 1;
obj->FlowControl->size[1] = 0;
obj->FlowControl->size[0] = 1;
obj->FlowControl->size[1] = 4;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj->FlowControl", "success"], 0, 32, 7))>;
obj->FlowControl->data[0] = 'n';
obj->FlowControl->data[1] = 'o';
obj->FlowControl->data[2] = 'n';
obj->FlowControl->data[3] = 'e';
obj_e = obj->TransportChannel;
success = obj_e->ByteOrder->size[0] * obj_e->ByteOrder->size[1];
obj_e->ByteOrder->size[0] = 1;
obj_e->ByteOrder->size[1] = 0;
obj_e->ByteOrder->size[0] = 1;
obj_e->ByteOrder->size[1] = 13;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj_e->ByteOrder", "success"], 0, 32, 8))>;
for (success = 0; success < 13; success++) {
    obj_e->ByteOrder->data[success] = tmp_p[success];
}
obj->ByteOrder->size[0] = 1;
obj->ByteOrder->size[1] = 0;
obj_e = obj->TransportChannel;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&out", "2"], 0, 32, 15))>;
success = out->size[0] * out->size[1];
out->size[0] = 1;
out->size[1] = obj_e->ByteOrder->size[1];
%<(SLibCGCallSubFcn("kt1e3yths5", ["out", "success"], 0, 32, 9))>;
loop_ub = obj_e->ByteOrder->size[1];
for (success = 0; success < loop_ub; success++) {
    out->data[success] = obj_e->ByteOrder->data[success];
}
success = obj->ByteOrder->size[0] * obj->ByteOrder->size[1];
obj->ByteOrder->size[0] = 1;
obj->ByteOrder->size[1] = out->size[1];
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj->ByteOrder", "success"], 0, 32, 10))>;
loop_ub = out->size[1] - 1;
for (success = 0; success <= loop_ub; success++) {
    obj->ByteOrder->data[success] = out->data[success];
}
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&out"], 0, 32, 16))>;
if (!obj->IsSharingExistingTimeout) {
    outputStream = &obj->AsyncIOChannel->OutputStream;
    inputStream = &obj->AsyncIOChannel->InputStream;
    outputStream->Timeout = 10.0;
    inputStream->Timeout = 10.0;
    obj->Timeout = 10.0;
}
obj->IsWriteOnly = false;
obj->IsSharingPort = true;
obj->IsSharingExistingTimeout = true;
success = obj->NativeDataType->size[0] * obj->NativeDataType->size[1];
obj->NativeDataType->size[0] = 1;
obj->NativeDataType->size[1] = 0;
obj->NativeDataType->size[0] = 1;
obj->NativeDataType->size[1] = 5;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj->NativeDataType", "success"], 0, 32, 11))>;
for (success = 0; success < 5; success++) {
    obj->NativeDataType->data[success] = tmp_e[success];
}
obj_e = obj->TransportChannel;
success = obj_e->NativeDataType->size[0] * obj_e->NativeDataType->size[1];
obj_e->NativeDataType->size[0] = 1;
obj_e->NativeDataType->size[1] = 0;
obj_e->NativeDataType->size[0] = 1;
obj_e->NativeDataType->size[1] = 5;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj_e->NativeDataType", "success"], 0, 32, 12))>;
for (success = 0; success < 5; success++) {
    obj_e->NativeDataType->data[success] = tmp_e[success];
}
success = obj->DataFieldName->size[0] * obj->DataFieldName->size[1];
obj->DataFieldName->size[0] = 1;
obj->DataFieldName->size[1] = 0;
obj->DataFieldName->size[0] = 1;
obj->DataFieldName->size[1] = 4;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj->DataFieldName", "success"], 0, 32, 13))>;
obj->DataFieldName->data[0] = 'D';
obj->DataFieldName->data[1] = 'a';
obj->DataFieldName->data[2] = 't';
obj->DataFieldName->data[3] = 'a';
obj_e = obj->TransportChannel;
success = obj_e->DataFieldName->size[0] * obj_e->DataFieldName->size[1];
obj_e->DataFieldName->size[0] = 1;
obj_e->DataFieldName->size[1] = 0;
obj_e->DataFieldName->size[0] = 1;
obj_e->DataFieldName->size[1] = 4;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj_e->DataFieldName", "success"], 0, 32, 14))>;
obj_e->DataFieldName->data[0] = 'D';
obj_e->DataFieldName->data[1] = 'a';
obj_e->DataFieldName->data[2] = 't';
obj_e->DataFieldName->data[3] = 'a';
obj->matlabCodegenIsDeleted = false;
return b_obj;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static fops2f5bc4 *p5lbt2unbb(\
%assign comma = ""
%<comma>fops2f5bc4 *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 32, fcnProtoType)>
%return fcnBuff
%endfunction

%function dyeylk2zzm_Fcn33(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
afxtk4erg3 *obj_p;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T b_value;
boolean_T hasSyncError;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,33,0,0)
%<SLibCG_AccessArg(0 ,33, 0)>
%endif

%<(SLibCGCallSubFcn("nokkyn0chr", ["obj"], 0, 33, 0))>;
obj_p = obj->AsyncIOChannel;
chImpl = obj_p->ChannelImpl;
success = coderChannelExecute(chImpl, "GetInitAccessStatus", 0);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
obj_p = obj->AsyncIOChannel;
b_value = obj_p->CustomProps.InitAccess;
chImpl = obj_p->ChannelImpl;
success = coderChannelGetPropertyValue(chImpl, "InitAccess", "logical", 1, &b_value);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
return b_value;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static boolean_T dyeylk2zzm(\
%assign comma = ""
%<comma>fops2f5bc4 *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 33, fcnProtoType)>
%return fcnBuff
%endfunction

%function ckmw2wjsvj_Fcn34(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
afxtk4erg3 *obj_p;
clvl5hd3q0 *outputStream;
hgyzgm1py1 *d;
hgyzgm1py1 *d_value;
hgyzgm1py1 *options_FlowControl;
hgyzgm1py1 *options_Parity;
i0lstc3zfv *inputStream;
real_T c[2];
real_T e[2];
real_T f[2];
real_T out;
real_T out_e;
real_T out_p;
int32_T loop_ub;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
char_T b[5];
boolean_T h[2];
boolean_T i[2];
boolean_T j[2];
boolean_T hasSyncError;
boolean_T options_IsSharingExistingTimeout;
boolean_T options_IsSharingPort;
boolean_T options_IsWriteOnly;
boolean_T result;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,34,3,0)
%<SLibCG_AccessArg(0 ,34, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,34,2,0)
%<SLibCG_AccessArg(0 ,34, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,34,1,0)
%<SLibCG_AccessArg(0 ,34, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,34,0,0)
%<SLibCG_AccessArg(0 ,34, 0)>
%endif

for (success = 0; success < 5; success++) {
    b[success] = obj->Port[success];
}
out = obj->BaudRate;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&options_Parity", "2"], 0, 34, 10))>;
success = options_Parity->size[0] * options_Parity->size[1];
options_Parity->size[0] = 1;
options_Parity->size[1] = obj->Parity->size[1];
%<(SLibCGCallSubFcn("kt1e3yths5", ["options_Parity", "success"], 0, 34, 4))>;
loop_ub = obj->Parity->size[1];
for (success = 0; success < loop_ub; success++) {
    options_Parity->data[success] = obj->Parity->data[success];
}
out_p = obj->StopBits;
out_e = obj->DataBits;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&options_FlowControl", "2"], 0, 34, 11))>;
success = options_FlowControl->size[0] * options_FlowControl->size[1];
options_FlowControl->size[0] = 1;
options_FlowControl->size[1] = obj->FlowControl->size[1];
%<(SLibCGCallSubFcn("kt1e3yths5", ["options_FlowControl", "success"], 0, 34, 5))>;
loop_ub = obj->FlowControl->size[1];
for (success = 0; success < loop_ub; success++) {
    options_FlowControl->data[success] = obj->FlowControl->data[success];
}
options_IsWriteOnly = obj->IsWriteOnly;
options_IsSharingPort = obj->IsSharingPort;
options_IsSharingExistingTimeout = obj->IsSharingExistingTimeout;
obj_p = obj->AsyncIOChannel;
chImpl = obj_p->ChannelImpl;
success = coderChannelIsOpen(chImpl, &result);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
if (!result) {
    chImpl = obj_p->ChannelImpl;
    %<(SLibCGCallSubFcn("c2wgnvw4uy", ["&d", "2"], 0, 34, 12))>;
    if (options_Parity->size[1] == 1) {
        success = d->size[0] * d->size[1];
        d->size[0] = 1;
        d->size[1] = 2;
        %<(SLibCGCallSubFcn("kt1e3yths5", ["d", "success"], 0, 34, 7))>;
        d->data[0] = options_Parity->data[0];
        d->data[1] = options_Parity->data[0];
    } else {
        success = d->size[0] * d->size[1];
        d->size[0] = 1;
        d->size[1] = options_Parity->size[1];
        %<(SLibCGCallSubFcn("kt1e3yths5", ["d", "success"], 0, 34, 6))>;
        loop_ub = options_Parity->size[1];
        if (loop_ub - 1 >= 0) {
            memcpy(&d->data[0], &options_Parity->data[0], (uint32_T)loop_ub * sizeof(char_T));
        }
    }
    %<(SLibCGCallSubFcn("c2wgnvw4uy", ["&d_value", "2"], 0, 34, 13))>;
    if (options_FlowControl->size[1] == 1) {
        success = d_value->size[0] * d_value->size[1];
        d_value->size[0] = 1;
        d_value->size[1] = 2;
        %<(SLibCGCallSubFcn("kt1e3yths5", ["d_value", "success"], 0, 34, 9))>;
        d_value->data[0] = options_FlowControl->data[0];
        d_value->data[1] = options_FlowControl->data[0];
    } else {
        success = d_value->size[0] * d_value->size[1];
        d_value->size[0] = 1;
        d_value->size[1] = options_FlowControl->size[1];
        %<(SLibCGCallSubFcn("kt1e3yths5", ["d_value", "success"], 0, 34, 8))>;
        loop_ub = options_FlowControl->size[1];
        if (loop_ub - 1 >= 0) {
            memcpy(&d_value->data[0], &options_FlowControl->data[0], (uint32_T)loop_ub * sizeof(char_T));
        }
    }
    c[0] = out;
    c[1] = out;
    e[0] = out_p;
    e[1] = out_p;
    f[0] = out_e;
    f[1] = out_e;
    h[0] = options_IsWriteOnly;
    h[1] = options_IsWriteOnly;
    i[0] = options_IsSharingPort;
    i[1] = options_IsSharingPort;
    j[0] = options_IsSharingExistingTimeout;
    j[1] = options_IsSharingExistingTimeout;
    success = coderChannelOpen(chImpl, 9, "ServiceName", "char", 5, &b[0], "BaudRate", "double", 1, &c[0], "Parity", "char", options_Parity->size[1], &d->data[0], "StopBits", "double", 1, &e[0], "DataBits", "double", 1, &f[0], "FlowControl", "char", options_FlowControl->size[1], &d_value->data[0], "IsWriteOnly", "logical", 1, &h[0], "IsSharingPort", "logical", 1, &i[0], "IsSharingExistingTimeout", "logical", 1, &j[0]);
    %<(SLibCGCallSubFcn("ec2asd4d0o", ["&d_value"], 0, 34, 17))>;
    %<(SLibCGCallSubFcn("ec2asd4d0o", ["&d"], 0, 34, 16))>;
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&options_FlowControl"], 0, 34, 15))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&options_Parity"], 0, 34, 14))>;
if (obj->IsSharingPort && (!obj->IsSharingExistingTimeout) && %<(SLibCGCallSubFcn("dyeylk2zzm", ["obj"], 0, 34, 0))>) {
    out = %<(SLibCGCallSubFcn("lcng5t0i0z", ["obj"], 0, 34, 1))>;
    %<(SLibCGCallSubFcn("nokkyn0chr", ["obj"], 0, 34, 2))>;
    obj_p = obj->AsyncIOChannel;
    chImpl = obj_p->ChannelImpl;
    c[0] = out;
    c[1] = out;
    success = coderChannelExecute(chImpl, "SetSharedTimeout", 1, "SharedTimeout", "double", 1, &c[0]);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
out = %<(SLibCGCallSubFcn("lcng5t0i0z", ["obj"], 0, 34, 3))>;
outputStream = &obj->AsyncIOChannel->OutputStream;
inputStream = &obj->AsyncIOChannel->InputStream;
outputStream->Timeout = out;
inputStream->Timeout = out;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void ckmw2wjsvj(\
%assign comma = ""
%<comma>fops2f5bc4 *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 34, fcnProtoType)>
%return fcnBuff
%endfunction

%function l1feuv03fp_Fcn35(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T y;
int32_T b_kstr;
int32_T minnanb;
boolean_T b_bool;
static const char_T tmp[128] = %<(TLC_STR_CTX(21))>;
static const char_T tmp_p[13] = %<(TLC_STR_CTX(22))>;
int32_T exitg1;
boolean_T guard1;
y = muDoubleScalarFloor(cmpLen);
b_bool = false;
b_kstr = a->size[1];
minnanb = muIntScalarMin_sint32(b_kstr, 13);
guard1 = false;
if ((int32_T)y <= minnanb) {
    b_kstr = (int32_T)y;
    minnanb = muIntScalarMin_sint32(minnanb, b_kstr);
    guard1 = true;
} else if (a->size[1] == 13) {
    minnanb = 13;
    guard1 = true;
}
if (guard1) {
    b_kstr = 1;
    do {
        exitg1 = 0;
        if (b_kstr - 1 <= (uint8_T)minnanb - 1) {
            if (tmp[(int32_T)((uint8_T)a->data[b_kstr - 1] & 127U)] != tmp[(int32_T)tmp_p[b_kstr - 1]]) {
                exitg1 = 1;
            } else {
                b_kstr++;
            }
        } else {
            b_bool = true;
            exitg1 = 1;
        }
    } while (exitg1 == 0);
}
return b_bool;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static boolean_T l1feuv03fp(\
%assign comma = ""
%<comma>const hgyzgm1py1 *a\
%assign comma = ", "
%<comma>real_T cmpLen\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 35, fcnProtoType)>
%return fcnBuff
%endfunction

%function pmpprwcsr4_Fcn36(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
afxtk4erg3 *obj_p;
habembxjyg *obj_e;
hgyzgm1py1 *out;
int32_T loop_ub;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
char_T b_value_data[13];
boolean_T hasSyncError;
static const char_T b_b[10] = %<(TLC_STR_CTX(23))>;
static const char_T tmp[13] = %<(TLC_STR_CTX(24))>;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,36,3,0)
%<SLibCG_AccessArg(0 ,36, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,36,2,0)
%<SLibCG_AccessArg(0 ,36, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,36,1,0)
%<SLibCG_AccessArg(0 ,36, 0)>
%endif

obj->isSetupComplete = false;
obj->isInitialized = 1;
obj->SaveOutput[0] = 0.0F;
obj->SaveOutput[1] = 0.0F;
obj->SaveOutput[2] = 0.0F;
obj->SaveOutput[3] = 0.0F;
%<(SLibCGCallSubFcn("p5lbt2unbb", ["&obj->SerialObj"], 0, 36, 1))>;
obj_p = obj->SerialObj.AsyncIOChannel;
chImpl = obj_p->ChannelImpl;
success = coderChannelIsOpen(chImpl, &hasSyncError);
if (success == 0) {
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
%<(SLibCGCallSubFcn("ckmw2wjsvj", ["&obj->SerialObj"], 0, 36, 3))>;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&out", "2"], 0, 36, 10))>;
success = out->size[0] * out->size[1];
out->size[0] = 1;
out->size[1] = obj->SerialObj.ByteOrder->size[1];
%<(SLibCGCallSubFcn("kt1e3yths5", ["out", "success"], 0, 36, 4))>;
loop_ub = obj->SerialObj.ByteOrder->size[1];
for (success = 0; success < loop_ub; success++) {
    out->data[success] = obj->SerialObj.ByteOrder->data[success];
}
obj_e = obj->SerialObj.TransportChannel;
if (%<(SLibCGCallSubFcn("l1feuv03fp", ["out", "(real_T)out->size[1]"], 0, 36, 0))>) {
    loop_ub = 13;
    for (success = 0; success < 13; success++) {
        b_value_data[success] = tmp[success];
    }
} else {
    loop_ub = 10;
    for (success = 0; success < 10; success++) {
        b_value_data[success] = b_b[success];
    }
}
success = obj_e->ByteOrder->size[0] * obj_e->ByteOrder->size[1];
obj_e->ByteOrder->size[0] = 1;
obj_e->ByteOrder->size[1] = 0;
obj_e->ByteOrder->size[0] = 1;
obj_e->ByteOrder->size[1] = loop_ub;
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj_e->ByteOrder", "success"], 0, 36, 5))>;
loop_ub--;
for (success = 0; success <= loop_ub; success++) {
    obj_e->ByteOrder->data[success] = b_value_data[success];
}
success = out->size[0] * out->size[1];
out->size[0] = 1;
out->size[1] = obj->SerialObj.NativeDataType->size[1];
%<(SLibCGCallSubFcn("kt1e3yths5", ["out", "success"], 0, 36, 6))>;
loop_ub = obj->SerialObj.NativeDataType->size[1];
for (success = 0; success < loop_ub; success++) {
    out->data[success] = obj->SerialObj.NativeDataType->data[success];
}
obj_e = obj->SerialObj.TransportChannel;
success = obj_e->NativeDataType->size[0] * obj_e->NativeDataType->size[1];
obj_e->NativeDataType->size[0] = 1;
obj_e->NativeDataType->size[1] = 0;
obj_e->NativeDataType->size[0] = 1;
obj_e->NativeDataType->size[1] = out->size[1];
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj_e->NativeDataType", "success"], 0, 36, 7))>;
loop_ub = out->size[1] - 1;
for (success = 0; success <= loop_ub; success++) {
    obj_e->NativeDataType->data[success] = out->data[success];
}
success = out->size[0] * out->size[1];
out->size[0] = 1;
out->size[1] = obj->SerialObj.DataFieldName->size[1];
%<(SLibCGCallSubFcn("kt1e3yths5", ["out", "success"], 0, 36, 8))>;
loop_ub = obj->SerialObj.DataFieldName->size[1];
for (success = 0; success < loop_ub; success++) {
    out->data[success] = obj->SerialObj.DataFieldName->data[success];
}
obj_e = obj->SerialObj.TransportChannel;
success = obj_e->DataFieldName->size[0] * obj_e->DataFieldName->size[1];
obj_e->DataFieldName->size[0] = 1;
obj_e->DataFieldName->size[1] = 0;
obj_e->DataFieldName->size[0] = 1;
obj_e->DataFieldName->size[1] = out->size[1];
%<(SLibCGCallSubFcn("kt1e3yths5", ["obj_e->DataFieldName", "success"], 0, 36, 9))>;
loop_ub = out->size[1] - 1;
for (success = 0; success <= loop_ub; success++) {
    obj_e->DataFieldName->data[success] = out->data[success];
}
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&out"], 0, 36, 11))>;
%<(SLibCGCallSubFcn("dyeylk2zzm", ["&obj->SerialObj"], 0, 36, 2))>;
obj->isSetupComplete = true;
obj->TunablePropsChanged = false;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void pmpprwcsr4(\
%assign comma = ""
%<comma>pry1oxlo21 *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 36, fcnProtoType)>
%return fcnBuff
%endfunction

%function au4z2r2bce_Fcn37(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
coderTimespec b_timespec;
if (!rtDW.iokbtv2z5c) {
    if (!rtDW.nurv532lwh) {
        rtDW.nurv532lwh = true;
        coderInitTimeFunctions(&rtDW.nbpfpt0bbn);
    }
    coderTimeClockGettimeMonotonic(&b_timespec, rtDW.nbpfpt0bbn);
    rtDW.iokbtv2z5c = true;
}
rtDW.eajxo4cjne.tv_sec = newTime_tv_sec;
rtDW.eajxo4cjne.tv_nsec = newTime_tv_nsec;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void au4z2r2bce(\
%assign comma = ""
%<comma>real_T newTime_tv_sec\
%assign comma = ", "
%<comma>real_T newTime_tv_nsec\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 37, fcnProtoType)>
%return fcnBuff
%endfunction

%function i2ato1xcxy_Fcn38(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
coderTimespec b_timespec;
if (!rtDW.nurv532lwh) {
    rtDW.nurv532lwh = true;
    coderInitTimeFunctions(&rtDW.nbpfpt0bbn);
}
coderTimeClockGettimeMonotonic(&b_timespec, rtDW.nbpfpt0bbn);
%<(SLibCGCallSubFcn("au4z2r2bce", ["b_timespec.tv_sec", "b_timespec.tv_nsec"], 0, 38, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void i2ato1xcxy(\
%assign comma = ""
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 38, fcnProtoType)>
%return fcnBuff
%endfunction

%function enuerpyldf_Fcn39(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
i3054vb1je *emxArray;
int32_T i;
*pEmxArray = (i3054vb1je *)malloc(sizeof(i3054vb1je));
emxArray = *pEmxArray;
emxArray->data = (real_T *)NULL;
emxArray->numDimensions = numDimensions;
emxArray->size = (int32_T *)malloc(sizeof(int32_T) * (uint32_T)numDimensions);
emxArray->allocatedSize = 0;
emxArray->canFreeData = true;
for (i = 0; i < numDimensions; i++) {
    emxArray->size[i] = 0;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void enuerpyldf(\
%assign comma = ""
%<comma>i3054vb1je **pEmxArray\
%assign comma = ", "
%<comma>int32_T numDimensions\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 39, fcnProtoType)>
%return fcnBuff
%endfunction

%function iv4amyl51q_Fcn40(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
he1ich2doy *emxArray;
int32_T i;
*pEmxArray = (he1ich2doy *)malloc(sizeof(he1ich2doy));
emxArray = *pEmxArray;
emxArray->data = (int32_T *)NULL;
emxArray->numDimensions = numDimensions;
emxArray->size = (int32_T *)malloc(sizeof(int32_T) * (uint32_T)numDimensions);
emxArray->allocatedSize = 0;
emxArray->canFreeData = true;
for (i = 0; i < numDimensions; i++) {
    emxArray->size[i] = 0;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void iv4amyl51q(\
%assign comma = ""
%<comma>he1ich2doy **pEmxArray\
%assign comma = ", "
%<comma>int32_T numDimensions\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 40, fcnProtoType)>
%return fcnBuff
%endfunction

%function au4z2r2bce5_Fcn41(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
*outTime_tv_sec = rtDW.eajxo4cjne.tv_sec;
*outTime_tv_nsec = rtDW.eajxo4cjne.tv_nsec;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void au4z2r2bce5(\
%assign comma = ""
%<comma>real_T *outTime_tv_sec\
%assign comma = ", "
%<comma>real_T *outTime_tv_nsec\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 41, fcnProtoType)>
%return fcnBuff
%endfunction

%function btyi2yuuqq_Fcn42(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
coderTimespec b_timespec;
real_T tstart_tv_nsec;
real_T tstart_tv_sec;
%<(SLibCGCallSubFcn("au4z2r2bce5", ["&tstart_tv_sec", "&tstart_tv_nsec"], 0, 42, 0))>;
if (!rtDW.nurv532lwh) {
    rtDW.nurv532lwh = true;
    coderInitTimeFunctions(&rtDW.nbpfpt0bbn);
}
coderTimeClockGettimeMonotonic(&b_timespec, rtDW.nbpfpt0bbn);
return (b_timespec.tv_nsec - tstart_tv_nsec) / 1.0E+9 + (b_timespec.tv_sec - tstart_tv_sec);
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static real_T btyi2yuuqq(\
%assign comma = ""
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 42, fcnProtoType)>
%return fcnBuff
%endfunction

%function dwh2lws3bw_Fcn43(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
real_T count;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T hasSyncError;
success = coderStreamGetDataAvailable(streamImpl, &count);
if (success == 0) {
    chImpl = coderStreamGetChannel(streamImpl);
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
return count;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static real_T dwh2lws3bw(\
%assign comma = ""
%<comma>CoderInputStream streamImpl\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 43, fcnProtoType)>
%return fcnBuff
%endfunction

%function m0m3nyxjg4_Fcn44(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T e;
int32_T f;
int32_T i;
int32_T i_p;
int32_T loop_ub;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,44,1,0)
%<SLibCG_AccessArg(0 ,44, 3)>
%endif

%if SLibCG_FcnCallArgAccessed(0,44,0,0)
%<SLibCG_AccessArg(0 ,44, 3)>
%endif

if ((packet->size[0] == 1) || (packet->size[1] == 1)) {
    if (startIndex > endIndex) {
        f = 0;
        e = 0;
    } else {
        f = (int32_T)startIndex - 1;
        e = (int32_T)endIndex;
    }
    i_p = result->size[0] * result->size[1];
    result->size[0] = 1;
    result->size[1] = e - f;
    %<(SLibCGCallSubFcn("fptaaqsn5k", ["result", "i_p"], 0, 44, 1))>;
    e -= f;
    for (i_p = 0; i_p < e; i_p++) {
        result->data[result->size[0] * i_p] = packet->data[f + i_p];
    }
} else {
    if (startIndex > endIndex) {
        f = 0;
        e = 0;
    } else {
        f = (int32_T)startIndex - 1;
        e = (int32_T)endIndex;
    }
    i_p = result->size[0] * result->size[1];
    result->size[0] = packet->size[0];
    result->size[1] = e - f;
    %<(SLibCGCallSubFcn("fptaaqsn5k", ["result", "i_p"], 0, 44, 0))>;
    e -= f;
    for (i_p = 0; i_p < e; i_p++) {
        loop_ub = packet->size[0];
        for (i = 0; i < loop_ub; i++) {
            result->data[i + result->size[0] * i_p] = packet->data[(f + i_p) * packet->size[0] + i];
        }
    }
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void m0m3nyxjg4(\
%assign comma = ""
%<comma>const ftbvbe5nvy *packet\
%assign comma = ", "
%<comma>real_T startIndex\
%assign comma = ", "
%<comma>real_T endIndex\
%assign comma = ", "
%<comma>ftbvbe5nvy *result\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 44, fcnProtoType)>
%return fcnBuff
%endfunction

%function m0m3nyxjg4a_Fcn45(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
int32_T i_p;
int32_T loop_ub;
int32_T loop_ub_p;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,45,1,0)
%<SLibCG_AccessArg(0 ,45, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,45,0,0)
%<SLibCG_AccessArg(0 ,45, 2)>
%endif

if ((packet->size[0] == 1) || (packet->size[1] == 1)) {
    if (endIndex < 1.0) {
        loop_ub = 0;
    } else {
        loop_ub = (int32_T)endIndex;
    }
    i_p = result->size[0] * result->size[1];
    result->size[0] = 1;
    result->size[1] = loop_ub;
    %<(SLibCGCallSubFcn("fptaaqsn5k", ["result", "i_p"], 0, 45, 1))>;
    for (i_p = 0; i_p < loop_ub; i_p++) {
        result->data[result->size[0] * i_p] = packet->data[i_p];
    }
} else {
    if (endIndex < 1.0) {
        loop_ub = 0;
    } else {
        loop_ub = (int32_T)endIndex;
    }
    i_p = result->size[0] * result->size[1];
    result->size[0] = packet->size[0];
    result->size[1] = loop_ub;
    %<(SLibCGCallSubFcn("fptaaqsn5k", ["result", "i_p"], 0, 45, 0))>;
    for (i_p = 0; i_p < loop_ub; i_p++) {
        loop_ub_p = packet->size[0];
        for (i = 0; i < loop_ub_p; i++) {
            result->data[i + result->size[0] * i_p] = packet->data[packet->size[0] * i_p + i];
        }
    }
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void m0m3nyxjg4a(\
%assign comma = ""
%<comma>const ftbvbe5nvy *packet\
%assign comma = ", "
%<comma>real_T endIndex\
%assign comma = ", "
%<comma>ftbvbe5nvy *result\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 45, fcnProtoType)>
%return fcnBuff
%endfunction

%function ol04rdb3hp_Fcn46(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
mwbcmoqwkf *emxArray;
int32_T i;
*pEmxArray = (mwbcmoqwkf *)malloc(sizeof(mwbcmoqwkf));
emxArray = *pEmxArray;
emxArray->data = (fdfwht03ld *)NULL;
emxArray->numDimensions = numDimensions;
emxArray->size = (int32_T *)malloc(sizeof(int32_T) * (uint32_T)numDimensions);
emxArray->allocatedSize = 0;
emxArray->canFreeData = true;
for (i = 0; i < numDimensions; i++) {
    emxArray->size[i] = 0;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void ol04rdb3hp(\
%assign comma = ""
%<comma>mwbcmoqwkf **pEmxArray\
%assign comma = ", "
%<comma>int32_T numDimensions\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 46, fcnProtoType)>
%return fcnBuff
%endfunction

%function i2ato1xcxyf_Fcn47(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
coderTimespec b_timespec;
if (!rtDW.nurv532lwh) {
    rtDW.nurv532lwh = true;
    coderInitTimeFunctions(&rtDW.nbpfpt0bbn);
}
coderTimeClockGettimeMonotonic(&b_timespec, rtDW.nbpfpt0bbn);
*tstart_tv_sec = b_timespec.tv_sec;
*tstart_tv_nsec = b_timespec.tv_nsec;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void i2ato1xcxyf(\
%assign comma = ""
%<comma>real_T *tstart_tv_sec\
%assign comma = ", "
%<comma>real_T *tstart_tv_nsec\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 47, fcnProtoType)>
%return fcnBuff
%endfunction

%function l1feuv03fpl_Fcn48(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T b_kstr;
boolean_T b_bool;
static const char_T tmp[128] = %<(TLC_STR_CTX(25))>;
static const char_T tmp_p[9] = %<(TLC_STR_CTX(26))>;
int32_T exitg1;
b_bool = false;
if (a_size[1] == 9) {
    b_kstr = 1;
    do {
        exitg1 = 0;
        if (b_kstr - 1 < 9) {
            if (tmp[(int32_T)((uint8_T)a_data[b_kstr - 1] & 127U)] != tmp[(int32_T)tmp_p[b_kstr - 1]]) {
                exitg1 = 1;
            } else {
                b_kstr++;
            }
        } else {
            b_bool = true;
            exitg1 = 1;
        }
    } while (exitg1 == 0);
}
return b_bool;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static boolean_T l1feuv03fpl(\
%assign comma = ""
%<comma>const char_T a_data[]\
%assign comma = ", "
%<comma>const int32_T a_size[2]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 48, fcnProtoType)>
%return fcnBuff
%endfunction

%function mem3fxtxvs_Fcn49(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,49,0,0)
%<SLibCG_AccessArg(0 ,49, 0)>
%endif

%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&pStruct->f1", "2"], 0, 49, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void mem3fxtxvs(\
%assign comma = ""
%<comma>fdfwht03ld *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 49, fcnProtoType)>
%return fcnBuff
%endfunction

%function per00giylg_Fcn50(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,50,0,0)
%<SLibCG_AccessArg(0 ,50, 0)>
%endif

for (i = fromIndex; i < toIndex; i++) {
    %<(SLibCGCallSubFcn("mem3fxtxvs", ["&emxArray->data[i]"], 0, 50, 0))>;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void per00giylg(\
%assign comma = ""
%<comma>mwbcmoqwkf *emxArray\
%assign comma = ", "
%<comma>int32_T fromIndex\
%assign comma = ", "
%<comma>int32_T toIndex\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 50, fcnProtoType)>
%return fcnBuff
%endfunction

%function hgyje4smkq_Fcn51(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,51,0,0)
%<SLibCG_AccessArg(0 ,51, 0)>
%endif

%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&pStruct->f1"], 0, 51, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void hgyje4smkq(\
%assign comma = ""
%<comma>fdfwht03ld *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 51, fcnProtoType)>
%return fcnBuff
%endfunction

%function ogluz30xc3_Fcn52(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,52,0,0)
%<SLibCG_AccessArg(0 ,52, 0)>
%endif

for (i = fromIndex; i < toIndex; i++) {
    %<(SLibCGCallSubFcn("hgyje4smkq", ["&emxArray->data[i]"], 0, 52, 0))>;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void ogluz30xc3(\
%assign comma = ""
%<comma>mwbcmoqwkf *emxArray\
%assign comma = ", "
%<comma>int32_T fromIndex\
%assign comma = ", "
%<comma>int32_T toIndex\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 52, fcnProtoType)>
%return fcnBuff
%endfunction

%function iumdyocwfs_Fcn53(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
int32_T newNumel;
void *newData;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,53,1,0)
%<SLibCG_AccessArg(0 ,53, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,53,1,1)
%<SLibCG_AccessArg(0 ,53, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,53,0,0)
%<SLibCG_AccessArg(0 ,53, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,53,0,2)
%<SLibCG_AccessArg(0 ,53, 1)>
%endif

if (oldNumel < 0) {
    oldNumel = 0;
}
newNumel = 1;
for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel *= emxArray->size[i];
}
if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
        i = 16;
    }
    while (i < newNumel) {
        if (i > 1073741823) {
            i = MAX_int32_T;
        } else {
            i <<= 1;
        }
    }
    newData = calloc((uint32_T)i, sizeof(fdfwht03ld));
    if (emxArray->data != NULL) {
        memcpy(newData, emxArray->data, sizeof(fdfwht03ld) * (uint32_T)oldNumel);
        if (emxArray->canFreeData) {
            free(emxArray->data);
        }
    }
    emxArray->data = (fdfwht03ld *)newData;
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
}
if (oldNumel > newNumel) {
    %<(SLibCGCallSubFcn("ogluz30xc3", ["emxArray", "newNumel", "oldNumel"], 0, 53, 0))>;
} else if (oldNumel < newNumel) {
    %<(SLibCGCallSubFcn("per00giylg", ["emxArray", "oldNumel", "newNumel"], 0, 53, 1))>;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void iumdyocwfs(\
%assign comma = ""
%<comma>mwbcmoqwkf *emxArray\
%assign comma = ", "
%<comma>int32_T oldNumel\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 53, fcnProtoType)>
%return fcnBuff
%endfunction

%function fln1whbkdj_Fcn54(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
ftbvbe5nvy *packet;
real_T bufferCounts[80];
real_T countToRead;
real_T numBuffers;
int32_T b_bufferIndex;
int32_T i;
int32_T outsize;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T hasSyncError;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,54,3,0)
%<SLibCG_AccessArg(0 ,54, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,54,1,0)
%<SLibCG_AccessArg(0 ,54, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,54,0,0)
%<SLibCG_AccessArg(0 ,54, 2)>
%endif

countToRead = 0.0;
memset(&bufferCounts[0], 0, 80U * sizeof(real_T));
numBuffers = 80.0;
success = coderInputStreamPeek(obj->StreamImpl, countRequested, &countToRead, &bufferCounts[0], &numBuffers);
if (success == 0) {
    chImpl = coderStreamGetChannel(obj->StreamImpl);
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
success = (int32_T)numBuffers;
i = packets->size[0] * packets->size[1];
packets->size[0] = 1;
packets->size[1] = (int32_T)numBuffers;
%<(SLibCGCallSubFcn("iumdyocwfs", ["packets", "i"], 0, 54, 0))>;
for (b_bufferIndex = 0; b_bufferIndex < success; b_bufferIndex++) {
    outsize = (int32_T)bufferCounts[b_bufferIndex];
    i = packets->data[b_bufferIndex].f1->size[0] * packets->data[b_bufferIndex].f1->size[1];
    packets->data[b_bufferIndex].f1->size[0] = 1;
    packets->data[b_bufferIndex].f1->size[1] = outsize;
    %<(SLibCGCallSubFcn("fptaaqsn5k", ["packets->data[b_bufferIndex].f1", "i"], 0, 54, 1))>;
    for (i = 0; i < outsize; i++) {
        packets->data[b_bufferIndex].f1->data[i] = 0U;
    }
}
success = coderInputStreamReadBuffers(obj->StreamImpl, countToRead, numBuffers);
if (success == 0) {
    chImpl = coderStreamGetChannel(obj->StreamImpl);
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
*countRead = 0.0;
outsize = (int32_T)numBuffers;
%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&packet", "2"], 0, 54, 4))>;
for (b_bufferIndex = 0; b_bufferIndex < outsize; b_bufferIndex++) {
    i = packet->size[0] * packet->size[1];
    packet->size[0] = 1;
    success = packets->data[b_bufferIndex].f1->size[1];
    packet->size[1] = success;
    %<(SLibCGCallSubFcn("fptaaqsn5k", ["packet", "i"], 0, 54, 2))>;
    for (i = 0; i < success; i++) {
        packet->data[i] = packets->data[b_bufferIndex].f1->data[i];
    }
    success = coderInputStreamReadBufferData(obj->StreamImpl, b_bufferIndex + 1, 1, "", "uint8", packets->data[b_bufferIndex].f1->size[1], &packet->data[0]);
    if (success == 0) {
        chImpl = coderStreamGetChannel(obj->StreamImpl);
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
    coderInputStreamFreeBuffer(obj->StreamImpl, b_bufferIndex + 1);
    i = packets->data[b_bufferIndex].f1->size[0] * packets->data[b_bufferIndex].f1->size[1];
    packets->data[b_bufferIndex].f1->size[0] = 1;
    packets->data[b_bufferIndex].f1->size[1] = packet->size[1];
    %<(SLibCGCallSubFcn("fptaaqsn5k", ["packets->data[b_bufferIndex].f1", "i"], 0, 54, 3))>;
    success = packet->size[1];
    for (i = 0; i < success; i++) {
        packets->data[b_bufferIndex].f1->data[i] = packet->data[i];
    }
    *countRead += bufferCounts[b_bufferIndex];
}
%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&packet"], 0, 54, 5))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void fln1whbkdj(\
%assign comma = ""
%<comma>const i0lstc3zfv *obj\
%assign comma = ", "
%<comma>real_T countRequested\
%assign comma = ", "
%<comma>mwbcmoqwkf *packets\
%assign comma = ", "
%<comma>real_T *countRead\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 54, fcnProtoType)>
%return fcnBuff
%endfunction

%function gs0i0ykog4_Fcn55(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T iy;
int32_T loop_ub;
int32_T y_p;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,55,1,0)
%<SLibCG_AccessArg(0 ,55, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,55,0,0)
%<SLibCG_AccessArg(0 ,55, 2)>
%endif

loop_ub = y->size[0] * y->size[1];
y->size[0] = varargin_1->size[0];
y->size[1] = varargin_1->size[1];
%<(SLibCGCallSubFcn("fptaaqsn5k", ["y", "loop_ub"], 0, 55, 0))>;
loop_ub = varargin_1->size[0] * varargin_1->size[1];
if (loop_ub - 1 >= 0) {
    memcpy(&y->data[0], &varargin_1->data[0], (uint32_T)loop_ub * sizeof(uint8_T));
}
loop_ub = y->size[0] * y->size[1];
y->size[0] = varargin_1->size[0];
y->size[1] = varargin_1->size[1] + varargin_2->size[1];
%<(SLibCGCallSubFcn("fptaaqsn5k", ["y", "loop_ub"], 0, 55, 1))>;
iy = varargin_1->size[0] * varargin_1->size[1];
y_p = varargin_2->size[1] - 1;
for (loop_ub = 0; loop_ub <= y_p; loop_ub++) {
    y->data[iy + loop_ub] = varargin_2->data[loop_ub];
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void gs0i0ykog4(\
%assign comma = ""
%<comma>const ftbvbe5nvy *varargin_1\
%assign comma = ", "
%<comma>const ftbvbe5nvy *varargin_2\
%assign comma = ", "
%<comma>ftbvbe5nvy *y\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 55, fcnProtoType)>
%return fcnBuff
%endfunction

%function l1feuv03fple_Fcn56(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T b_kstr;
boolean_T b_bool;
static const char_T tmp[128] = %<(TLC_STR_CTX(27))>;
static const char_T tmp_p[7] = %<(TLC_STR_CTX(28))>;
int32_T exitg1;
b_bool = false;
if (a_size[1] == 7) {
    b_kstr = 1;
    do {
        exitg1 = 0;
        if (b_kstr - 1 < 7) {
            if (tmp[(int32_T)((uint8_T)a_data[b_kstr - 1] & 127U)] != tmp[(int32_T)tmp_p[b_kstr - 1]]) {
                exitg1 = 1;
            } else {
                b_kstr++;
            }
        } else {
            b_bool = true;
            exitg1 = 1;
        }
    } while (exitg1 == 0);
}
return b_bool;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static boolean_T l1feuv03fple(\
%assign comma = ""
%<comma>const char_T a_data[]\
%assign comma = ", "
%<comma>const int32_T a_size[2]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 56, fcnProtoType)>
%return fcnBuff
%endfunction

%function l1feuv03fpleo_Fcn57(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T b_kstr;
boolean_T b_bool;
static const char_T tmp[128] = %<(TLC_STR_CTX(29))>;
static const char_T tmp_p[4] = %<(TLC_STR_CTX(30))>;
int32_T exitg1;
b_bool = false;
if (a_size[1] == 4) {
    b_kstr = 1;
    do {
        exitg1 = 0;
        if (b_kstr - 1 < 4) {
            if (tmp[(int32_T)((uint8_T)a_data[b_kstr - 1] & 127U)] != tmp[(int32_T)tmp_p[b_kstr - 1]]) {
                exitg1 = 1;
            } else {
                b_kstr++;
            }
        } else {
            b_bool = true;
            exitg1 = 1;
        }
    } while (exitg1 == 0);
}
return b_bool;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static boolean_T l1feuv03fpleo(\
%assign comma = ""
%<comma>const char_T a_data[]\
%assign comma = ", "
%<comma>const int32_T a_size[2]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 57, fcnProtoType)>
%return fcnBuff
%endfunction

%function o55ouaau02_Fcn58(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
int32_T numEl;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,58,0,0)
%<SLibCG_AccessArg(0 ,58, 0)>
%endif

if (*pEmxArray != (mwbcmoqwkf *)NULL) {
    if ((*pEmxArray)->data != (fdfwht03ld *)NULL) {
        numEl = 1;
        for (i = 0; i < (*pEmxArray)->numDimensions; i++) {
            numEl *= (*pEmxArray)->size[i];
        }
        for (i = 0; i < numEl; i++) {
            %<(SLibCGCallSubFcn("hgyje4smkq", ["&(*pEmxArray)->data[i]"], 0, 58, 0))>;
        }
        if ((*pEmxArray)->canFreeData) {
            free((*pEmxArray)->data);
        }
    }
    free((*pEmxArray)->size);
    free(*pEmxArray);
    *pEmxArray = (mwbcmoqwkf *)NULL;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void o55ouaau02(\
%assign comma = ""
%<comma>mwbcmoqwkf **pEmxArray\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 58, fcnProtoType)>
%return fcnBuff
%endfunction

%function btyi2yuuqqr_Fcn59(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
coderTimespec b_timespec;
if (!rtDW.nurv532lwh) {
    rtDW.nurv532lwh = true;
    coderInitTimeFunctions(&rtDW.nbpfpt0bbn);
}
coderTimeClockGettimeMonotonic(&b_timespec, rtDW.nbpfpt0bbn);
return (b_timespec.tv_nsec - tstart_tv_nsec) / 1.0E+9 + (b_timespec.tv_sec - tstart_tv_sec);
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static real_T btyi2yuuqqr(\
%assign comma = ""
%<comma>real_T tstart_tv_sec\
%assign comma = ", "
%<comma>real_T tstart_tv_nsec\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 59, fcnProtoType)>
%return fcnBuff
%endfunction

%function jrnq5jhfee_Fcn60(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
coderTimespec b_timespec;
real_T delay;
real_T delayInt;
delay = varargin_1;
if (muDoubleScalarIsNaN(varargin_1)) {
    delay = 0.0;
}
delayInt = muDoubleScalarFloor(delay);
delay -= delayInt;
b_timespec.tv_sec = delayInt;
if (delay > 0.0) {
    b_timespec.tv_nsec = muDoubleScalarFloor(delay * 1.0E+9);
} else {
    b_timespec.tv_nsec = 0.0;
}
coderTimeSleep(&b_timespec);
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void jrnq5jhfee(\
%assign comma = ""
%<comma>real_T varargin_1\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 60, fcnProtoType)>
%return fcnBuff
%endfunction

%function k1scvijul4_Fcn61(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T hasSyncError;
boolean_T result;
success = coderStreamIsDeviceDone(obj->StreamImpl, &result);
if (success == 0) {
    chImpl = coderStreamGetChannel(obj->StreamImpl);
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
return result;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static boolean_T k1scvijul4(\
%assign comma = ""
%<comma>const i0lstc3zfv *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 61, fcnProtoType)>
%return fcnBuff
%endfunction

%function irhvzala2k_Fcn62(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T hasSyncError;
boolean_T result;
success = coderStreamIsOpen(obj->StreamImpl, &result);
if (success == 0) {
    chImpl = coderStreamGetChannel(obj->StreamImpl);
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
return result;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static boolean_T irhvzala2k(\
%assign comma = ""
%<comma>const i0lstc3zfv *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 62, fcnProtoType)>
%return fcnBuff
%endfunction

%function d1cnfcxsqs_Fcn63(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
ftbvbe5nvy *excessData;
ftbvbe5nvy *tempDataRead;
i0lstc3zfv *obj_p;
mwbcmoqwkf *packets;
real_T et;
real_T ppc;
real_T pps;
real_T startTic_tv_nsec;
int32_T b_ii;
int32_T obj_e;
char_T status_data[9];
boolean_T completed;
boolean_T done;
boolean_T timeout;
static const char_T tmp[9] = %<(TLC_STR_CTX(31))>;
static const char_T tmp_p[7] = %<(TLC_STR_CTX(32))>;
ftbvbe5nvy *data_e;
ftbvbe5nvy *data_i;
ftbvbe5nvy *data_p;
int32_T status_size[2];
int32_T exitg1;
int32_T loop_ub;
boolean_T guard1;
boolean_T guard11;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,63,25,0)
%<SLibCG_AccessArg(0 ,63, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,63,24,0)
%<SLibCG_AccessArg(0 ,63, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,63,21,0)
%<SLibCG_AccessArg(0 ,63, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,63,18,0)
%<SLibCG_AccessArg(0 ,63, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,63,15,2)
%<SLibCG_AccessArg(0 ,63, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,63,12,0)
%<SLibCG_AccessArg(0 ,63, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,63,11,1)
%<SLibCG_AccessArg(0 ,63, 2)>
%endif
%if SLibCG_FcnCallArgAccessed(0,63,11,2)
%<SLibCG_AccessArg(0 ,63, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,63,10,0)
%<SLibCG_AccessArg(0 ,63, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,63,9,0)
%<SLibCG_AccessArg(0 ,63, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,63,9,2)
%<SLibCG_AccessArg(0 ,63, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,63,8,0)
%<SLibCG_AccessArg(0 ,63, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,63,8,1)
%<SLibCG_AccessArg(0 ,63, 1)>
%<SLibCG_AccessArg(0 ,63, 3)>
%endif

%if SLibCG_FcnCallArgAccessed(0,63,7,1)
%<SLibCG_AccessArg(0 ,63, 1)>
%endif
%if SLibCG_FcnCallArgAccessed(0,63,7,2)
%<SLibCG_AccessArg(0 ,63, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,63,6,0)
%<SLibCG_AccessArg(0 ,63, 2)>
%endif
%if SLibCG_FcnCallArgAccessed(0,63,6,1)
%<SLibCG_AccessArg(0 ,63, 1)>
%endif
%if SLibCG_FcnCallArgAccessed(0,63,6,2)
%<SLibCG_AccessArg(0 ,63, 3)>
%endif

%if SLibCG_FcnCallArgAccessed(0,63,5,2)
%<SLibCG_AccessArg(0 ,63, 2)>
%endif

loop_ub = obj->ExampleData->size[0] * obj->ExampleData->size[1];
obj->ExampleData->size[0] = 1;
obj->ExampleData->size[1] = 1;
%<(SLibCGCallSubFcn("fptaaqsn5k", ["obj->ExampleData", "loop_ub"], 0, 63, 21))>;
obj->ExampleData->data[0] = 0U;
err_size[0] = 1;
err_size[1] = 0;
ppc = obj->PartialPacketCount;
%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&excessData", "2"], 0, 63, 28))>;
if (ppc > 0.0) {
    pps = obj->PartialPacketStart;
    %<(SLibCGCallSubFcn("mw2mi4zvh2", ["&tempDataRead", "2"], 0, 63, 30))>;
    if (countRequested < ppc) {
        %<(SLibCGCallSubFcn("m0m3nyxjg4", ["obj->PartialPacket", "pps", "(pps + countRequested) - 1.0", "tempDataRead"], 0, 63, 9))>;
        *countRead = countRequested;
        obj->PartialPacketStart = pps + countRequested;
        obj->PartialPacketCount = ppc - countRequested;
    } else {
        %<(SLibCGCallSubFcn("m0m3nyxjg4", ["obj->PartialPacket", "pps", "(pps + ppc) - 1.0", "tempDataRead"], 0, 63, 10))>;
        *countRead = ppc;
        loop_ub = excessData->size[0] * excessData->size[1];
        excessData->size[0] = obj->ExampleData->size[0];
        %<(SLibCGCallSubFcn("fptaaqsn5k", ["excessData", "loop_ub"], 0, 63, 22))>;
        obj->PartialPacket->size[0] = excessData->size[0];
        obj->PartialPacket->size[1] = 0;
        obj->PartialPacketStart = 0.0;
        obj->PartialPacketCount = 0.0;
    }
    %<(SLibCGCallSubFcn("m0m3nyxjg4a", ["tempDataRead", "(real_T)tempDataRead->size[1]", "data"], 0, 63, 15))>;
    %<(SLibCGCallSubFcn("lv0yfzd1c2", ["&tempDataRead"], 0, 63, 36))>;
} else {
    data->size[0] = 1;
    data->size[1] = 0;
    *countRead = 0.0;
}
if (*countRead == countRequested) {
    %<(SLibCGCallSubFcn("mw2mi4zvh2", ["&data_p", "2"], 0, 63, 31))>;
    loop_ub = data_p->size[0] * data_p->size[1];
    data_p->size[0] = data->size[0];
    data_p->size[1] = data->size[1];
    %<(SLibCGCallSubFcn("fptaaqsn5k", ["data_p", "loop_ub"], 0, 63, 23))>;
    loop_ub = data->size[0] * data->size[1] - 1;
    if (loop_ub >= 0) {
        memcpy(&data_p->data[0], &data->data[0], (uint32_T)(loop_ub + 1) * sizeof(uint8_T));
    }
    %<(SLibCGCallSubFcn("m0m3nyxjg4a", ["data_p", "(real_T)data->size[1]", "data"], 0, 63, 11))>;
    %<(SLibCGCallSubFcn("lv0yfzd1c2", ["&data_p"], 0, 63, 37))>;
} else {
    %<(SLibCGCallSubFcn("ol04rdb3hp", ["&packets", "2"], 0, 63, 29))>;
    %<(SLibCGCallSubFcn("mw2mi4zvh2", ["&data_e", "2"], 0, 63, 32))>;
    %<(SLibCGCallSubFcn("mw2mi4zvh2", ["&data_i", "2"], 0, 63, 33))>;
    guard1 = false;
    do {
        exitg1 = 0;
        if (*countRead < countRequested) {
            et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->StreamImpl"], 0, 63, 12))>;
            guard11 = false;
            if (et == 0.0) {
                obj_p = obj;
                ppc = obj->Timeout;
                status_size[0] = 1;
                status_size[1] = 0;
                timeout = false;
                done = false;
                et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->StreamImpl"], 0, 63, 18))>;
                completed = (et > 0.0);
                %<(SLibCGCallSubFcn("i2ato1xcxyf", ["&pps", "&startTic_tv_nsec"], 0, 63, 20))>;
                while ((!completed) && (!done) && (!timeout)) {
                    et = %<(SLibCGCallSubFcn("btyi2yuuqqr", ["pps", "startTic_tv_nsec"], 0, 63, 13))>;
                    if (et < 1.0) {
                        %<(SLibCGCallSubFcn("jrnq5jhfee", ["0.0"], 0, 63, 17))>;
                    } else {
                        %<(SLibCGCallSubFcn("jrnq5jhfee", ["0.005"], 0, 63, 16))>;
                    }
                    et = %<(SLibCGCallSubFcn("btyi2yuuqqr", ["pps", "startTic_tv_nsec"], 0, 63, 14))>;
                    timeout = (et > ppc);
                    if (%<(SLibCGCallSubFcn("k1scvijul4", ["obj_p"], 0, 63, 3))> || (!%<(SLibCGCallSubFcn("irhvzala2k", ["obj_p"], 0, 63, 4))>)) {
                        done = true;
                    }
                    et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj_p->StreamImpl"], 0, 63, 19))>;
                    completed = (et > 0.0);
                }
                if (completed) {
                    status_size[0] = 1;
                    status_size[1] = 9;
                    for (b_ii = 0; b_ii < 9; b_ii++) {
                        status_data[b_ii] = tmp[b_ii];
                    }
                } else if (done) {
                    status_size[0] = 1;
                    status_size[1] = 4;
                    status_data[0] = 'd';
                    status_data[1] = 'o';
                    status_data[2] = 'n';
                    status_data[3] = 'e';
                } else if (timeout) {
                    status_size[0] = 1;
                    status_size[1] = 7;
                    for (b_ii = 0; b_ii < 7; b_ii++) {
                        status_data[b_ii] = tmp_p[b_ii];
                    }
                }
                if (!%<(SLibCGCallSubFcn("l1feuv03fpl", ["status_data", "status_size"], 0, 63, 0))>) {
                    err_size[0] = 1;
                    err_size[1] = status_size[1];
                    loop_ub = status_size[1];
                    if (loop_ub - 1 >= 0) {
                        memcpy(&err_data[0], &status_data[0], (uint32_T)loop_ub * sizeof(char_T));
                    }
                    if (%<(SLibCGCallSubFcn("l1feuv03fple", ["status_data", "status_size"], 0, 63, 1))>) {
                        data->size[0] = 1;
                        data->size[1] = 0;
                    } else {
                        if (%<(SLibCGCallSubFcn("l1feuv03fpleo", ["status_data", "status_size"], 0, 63, 2))>) {
                            err_size[0] = 1;
                            err_size[1] = 0;
                        }
                        guard1 = true;
                    }
                    exitg1 = 1;
                } else {
                    guard11 = true;
                }
            } else {
                guard11 = true;
            }
            if (guard11) {
                %<(SLibCGCallSubFcn("fln1whbkdj", ["obj", "countRequested - *countRead", "packets", "&et"], 0, 63, 8))>;
                obj_e = packets->size[1];
                for (b_ii = 0; b_ii < obj_e; b_ii++) {
                    loop_ub = data_i->size[0] * data_i->size[1];
                    data_i->size[0] = data->size[0];
                    data_i->size[1] = data->size[1];
                    %<(SLibCGCallSubFcn("fptaaqsn5k", ["data_i", "loop_ub"], 0, 63, 26))>;
                    loop_ub = data->size[0] * data->size[1] - 1;
                    if (loop_ub >= 0) {
                        memcpy(&data_i->data[0], &data->data[0], (uint32_T)(loop_ub + 1) * sizeof(uint8_T));
                    }
                    %<(SLibCGCallSubFcn("gs0i0ykog4", ["data_i", "packets->data[b_ii].f1", "data"], 0, 63, 5))>;
                }
                *countRead += et;
                guard1 = false;
            }
        } else {
            guard1 = true;
            exitg1 = 1;
        }
    } while (exitg1 == 0);
    if (guard1) {
        if (*countRead > countRequested) {
            %<(SLibCGCallSubFcn("m0m3nyxjg4", ["data", "countRequested + 1.0", "*countRead", "excessData"], 0, 63, 6))>;
            loop_ub = obj->PartialPacket->size[0] * obj->PartialPacket->size[1];
            obj->PartialPacket->size[0] = excessData->size[0];
            obj->PartialPacket->size[1] = excessData->size[1];
            %<(SLibCGCallSubFcn("fptaaqsn5k", ["obj->PartialPacket", "loop_ub"], 0, 63, 24))>;
            loop_ub = excessData->size[0] * excessData->size[1];
            for (b_ii = 0; b_ii < loop_ub; b_ii++) {
                obj->PartialPacket->data[b_ii] = excessData->data[b_ii];
            }
            obj->PartialPacketStart = 1.0;
            obj->PartialPacketCount = excessData->size[1];
            loop_ub = data_e->size[0] * data_e->size[1];
            data_e->size[0] = data->size[0];
            data_e->size[1] = data->size[1];
            %<(SLibCGCallSubFcn("fptaaqsn5k", ["data_e", "loop_ub"], 0, 63, 27))>;
            loop_ub = data->size[0] * data->size[1] - 1;
            if (loop_ub >= 0) {
                memcpy(&data_e->data[0], &data->data[0], (uint32_T)(loop_ub + 1) * sizeof(uint8_T));
            }
            %<(SLibCGCallSubFcn("m0m3nyxjg4a", ["data_e", "countRequested", "data"], 0, 63, 7))>;
            *countRead = countRequested;
        }
        if (err_size[1] != 0) {
            loop_ub = obj->PartialPacket->size[0] * obj->PartialPacket->size[1];
            obj->PartialPacket->size[0] = data->size[0];
            obj->PartialPacket->size[1] = data->size[1];
            %<(SLibCGCallSubFcn("fptaaqsn5k", ["obj->PartialPacket", "loop_ub"], 0, 63, 25))>;
            loop_ub = data->size[0] * data->size[1];
            for (b_ii = 0; b_ii < loop_ub; b_ii++) {
                obj->PartialPacket->data[b_ii] = data->data[b_ii];
            }
            obj->PartialPacketStart = 1.0;
            obj->PartialPacketCount = data->size[1];
            data->size[0] = 1;
            data->size[1] = 0;
            *countRead = 0.0;
        }
    }
    %<(SLibCGCallSubFcn("lv0yfzd1c2", ["&data_i"], 0, 63, 39))>;
    %<(SLibCGCallSubFcn("lv0yfzd1c2", ["&data_e"], 0, 63, 38))>;
    %<(SLibCGCallSubFcn("o55ouaau02", ["&packets"], 0, 63, 35))>;
}
%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&excessData"], 0, 63, 34))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void d1cnfcxsqs(\
%assign comma = ""
%<comma>i0lstc3zfv *obj\
%assign comma = ", "
%<comma>real_T countRequested\
%assign comma = ", "
%<comma>ftbvbe5nvy *data\
%assign comma = ", "
%<comma>real_T *countRead\
%assign comma = ", "
%<comma>char_T err_data[]\
%assign comma = ", "
%<comma>int32_T err_size[2]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 63, fcnProtoType)>
%return fcnBuff
%endfunction

%function byeglscfzf_Fcn64(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,64,0,0)
%<SLibCG_AccessArg(0 ,64, 0)>
%endif

%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&pStruct->f1", "2"], 0, 64, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void byeglscfzf(\
%assign comma = ""
%<comma>kyfiexkdtl *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 64, fcnProtoType)>
%return fcnBuff
%endfunction

%function as4usvjcgi_Fcn65(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
pEmxArray->size = 0;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void as4usvjcgi(\
%assign comma = ""
%<comma>aa555fgs2y *pEmxArray\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 65, fcnProtoType)>
%return fcnBuff
%endfunction

%function cqil0vzmra_Fcn66(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
real_T count;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T hasSyncError;
success = coderStreamGetSpaceAvailable(obj->StreamImpl, &count);
if (success == 0) {
    chImpl = coderStreamGetChannel(obj->StreamImpl);
    coderChannelHasSyncError(chImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
    }
}
return count;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static real_T cqil0vzmra(\
%assign comma = ""
%<comma>const clvl5hd3q0 *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 66, fcnProtoType)>
%return fcnBuff
%endfunction

%function a5gqemnbab_Fcn67(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
real_T et;
real_T startTic_tv_nsec;
real_T startTic_tv_sec;
real_T timeoutInSeconds;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T completed;
boolean_T done;
boolean_T timeout;
static const char_T tmp[9] = %<(TLC_STR_CTX(33))>;
static const char_T tmp_p[7] = %<(TLC_STR_CTX(34))>;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,67,3,0)
%<SLibCG_AccessArg(0 ,67, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,67,0,0)
%<SLibCG_AccessArg(0 ,67, 0)>
%endif

timeoutInSeconds = obj->Timeout;
status_size[0] = 1;
status_size[1] = 0;
timeout = false;
done = false;
completed = (%<(SLibCGCallSubFcn("cqil0vzmra", ["obj"], 0, 67, 3))> > 0.0);
%<(SLibCGCallSubFcn("i2ato1xcxyf", ["&startTic_tv_sec", "&startTic_tv_nsec"], 0, 67, 6))>;
while ((!completed) && (!done) && (!timeout)) {
    et = %<(SLibCGCallSubFcn("btyi2yuuqqr", ["startTic_tv_sec", "startTic_tv_nsec"], 0, 67, 5))>;
    if (et < 1.0) {
        %<(SLibCGCallSubFcn("jrnq5jhfee", ["0.0"], 0, 67, 1))>;
    } else {
        %<(SLibCGCallSubFcn("jrnq5jhfee", ["0.005"], 0, 67, 2))>;
    }
    et = %<(SLibCGCallSubFcn("btyi2yuuqqr", ["startTic_tv_sec", "startTic_tv_nsec"], 0, 67, 4))>;
    timeout = (et > timeoutInSeconds);
    success = coderStreamIsDeviceDone(obj->StreamImpl, &done);
    if (success == 0) {
        chImpl = coderStreamGetChannel(obj->StreamImpl);
        coderChannelHasSyncError(chImpl, &completed);
        if (!completed) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
    if (done) {
        done = true;
    } else {
        success = coderStreamIsOpen(obj->StreamImpl, &done);
        if (success == 0) {
            chImpl = coderStreamGetChannel(obj->StreamImpl);
            coderChannelHasSyncError(chImpl, &completed);
            if (!completed) {
                coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
            } else {
                coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
            }
        }
        if (!done) {
            done = true;
        } else {
            done = false;
        }
    }
    completed = (%<(SLibCGCallSubFcn("cqil0vzmra", ["obj"], 0, 67, 0))> > 0.0);
}
if (completed) {
    status_size[0] = 1;
    status_size[1] = 9;
    for (success = 0; success < 9; success++) {
        status_data[success] = tmp[success];
    }
} else if (done) {
    status_size[0] = 1;
    status_size[1] = 4;
    status_data[0] = 'd';
    status_data[1] = 'o';
    status_data[2] = 'n';
    status_data[3] = 'e';
} else if (timeout) {
    status_size[0] = 1;
    status_size[1] = 7;
    for (success = 0; success < 7; success++) {
        status_data[success] = tmp_p[success];
    }
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void a5gqemnbab(\
%assign comma = ""
%<comma>const clvl5hd3q0 *obj\
%assign comma = ", "
%<comma>char_T status_data[]\
%assign comma = ", "
%<comma>int32_T status_size[2]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 67, fcnProtoType)>
%return fcnBuff
%endfunction

%function ojf3rzyptf_Fcn68(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,68,0,0)
%<SLibCG_AccessArg(0 ,68, 0)>
%endif

for (i = fromIndex; i < toIndex; i++) {
    %<(SLibCGCallSubFcn("byeglscfzf", ["data"], 0, 68, 0))>;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void ojf3rzyptf(\
%assign comma = ""
%<comma>kyfiexkdtl *data\
%assign comma = ", "
%<comma>int32_T fromIndex\
%assign comma = ", "
%<comma>int32_T toIndex\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 68, fcnProtoType)>
%return fcnBuff
%endfunction

%function aqxvg4ncr3_Fcn69(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,69,0,0)
%<SLibCG_AccessArg(0 ,69, 0)>
%endif

%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&pStruct->f1"], 0, 69, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void aqxvg4ncr3(\
%assign comma = ""
%<comma>kyfiexkdtl *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 69, fcnProtoType)>
%return fcnBuff
%endfunction

%function ptumt23wq4_Fcn70(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,70,0,0)
%<SLibCG_AccessArg(0 ,70, 0)>
%endif

for (i = fromIndex; i < toIndex; i++) {
    %<(SLibCGCallSubFcn("aqxvg4ncr3", ["data"], 0, 70, 0))>;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void ptumt23wq4(\
%assign comma = ""
%<comma>kyfiexkdtl *data\
%assign comma = ", "
%<comma>int32_T fromIndex\
%assign comma = ", "
%<comma>int32_T toIndex\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 70, fcnProtoType)>
%return fcnBuff
%endfunction

%function ekhc0cwc2a_Fcn71(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T newNumel;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,71,1,0)
%<SLibCG_AccessArg(0 ,71, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,71,1,1)
%<SLibCG_AccessArg(0 ,71, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,71,0,0)
%<SLibCG_AccessArg(0 ,71, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,71,0,2)
%<SLibCG_AccessArg(0 ,71, 2)>
%endif

if (oldNumel < 0) {
    oldNumel = 0;
}
newNumel = *size;
if (oldNumel > newNumel) {
    %<(SLibCGCallSubFcn("ptumt23wq4", ["data", "newNumel", "oldNumel"], 0, 71, 0))>;
} else if (oldNumel < newNumel) {
    %<(SLibCGCallSubFcn("ojf3rzyptf", ["data", "oldNumel", "newNumel"], 0, 71, 1))>;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void ekhc0cwc2a(\
%assign comma = ""
%<comma>kyfiexkdtl *data\
%assign comma = ", "
%<comma>const int32_T *size\
%assign comma = ", "
%<comma>int32_T oldNumel\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 71, fcnProtoType)>
%return fcnBuff
%endfunction

%function h2txudbtwt_Fcn72(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
int32_T numElDst;
int32_T numElSrc;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,72,0,0)
%<SLibCG_AccessArg(0 ,72, 0)>
%endif

numElDst = 1;
numElSrc = 1;
for (i = 0; i < (*dst)->numDimensions; i++) {
    numElDst *= (*dst)->size[i];
    numElSrc *= (*src)->size[i];
}
for (i = 0; i < (*dst)->numDimensions; i++) {
    (*dst)->size[i] = (*src)->size[i];
}
%<(SLibCGCallSubFcn("fptaaqsn5k", ["*dst", "numElDst"], 0, 72, 0))>;
for (i = 0; i < numElSrc; i++) {
    (*dst)->data[i] = (*src)->data[i];
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void h2txudbtwt(\
%assign comma = ""
%<comma>ftbvbe5nvy **dst\
%assign comma = ", "
%<comma>ftbvbe5nvy * const *src\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 72, fcnProtoType)>
%return fcnBuff
%endfunction

%function fzkkuo0c5t_Fcn73(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,73,0,0)
%<SLibCG_AccessArg(0 ,73, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,73,0,1)
%<SLibCG_AccessArg(0 ,73, 1)>
%endif

%<(SLibCGCallSubFcn("h2txudbtwt", ["&dst->f1", "&src->f1"], 0, 73, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void fzkkuo0c5t(\
%assign comma = ""
%<comma>kyfiexkdtl *dst\
%assign comma = ", "
%<comma>const kyfiexkdtl *src\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 73, fcnProtoType)>
%return fcnBuff
%endfunction

%function jv3xezhw0x_Fcn74(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
int32_T numEl;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,74,0,0)
%<SLibCG_AccessArg(0 ,74, 0)>
%endif

numEl = 1;
for (i = 0; i < 1; i++) {
    numEl *= pEmxArray->size;
}
for (i = 0; i < numEl; i++) {
    %<(SLibCGCallSubFcn("aqxvg4ncr3", ["&pEmxArray->data"], 0, 74, 0))>;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void jv3xezhw0x(\
%assign comma = ""
%<comma>aa555fgs2y *pEmxArray\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 74, fcnProtoType)>
%return fcnBuff
%endfunction

%function g1pihrrgkp_Fcn75(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
aa555fgs2y c_p;
kyfiexkdtl c;
real_T count;
real_T countWritten;
real_T countWrittenThisIteration;
real_T packetEndIndex;
real_T packetStartIndex;
int32_T status_size[2];
int32_T ii;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
char_T status_data[9];
boolean_T exitg1;
boolean_T exitg2;
boolean_T guard1;
boolean_T hasSyncError;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,75,2,0)
%<SLibCG_AccessArg(0 ,75, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,75,0,0)
%<SLibCG_AccessArg(0 ,75, 0)>
%endif

obj->BytesPerElement = 1.0;
countWritten = 0.0;
%<(SLibCGCallSubFcn("byeglscfzf", ["&c"], 0, 75, 6))>;
success = c.f1->size[0] * c.f1->size[1];
c.f1->size[0] = data->size[0];
c.f1->size[1] = data->size[1];
%<(SLibCGCallSubFcn("fptaaqsn5k", ["c.f1", "success"], 0, 75, 4))>;
success = data->size[0] * data->size[1];
for (ii = 0; ii < success; ii++) {
    c.f1->data[ii] = data->data[ii];
}
packetStartIndex = 1.0;
%<(SLibCGCallSubFcn("as4usvjcgi", ["&c_p"], 0, 75, 7))>;
exitg1 = false;
while ((!exitg1) && (countWritten < data->size[1])) {
    guard1 = false;
    if (%<(SLibCGCallSubFcn("cqil0vzmra", ["&obj->OutputStream"], 0, 75, 0))> == 0.0) {
        %<(SLibCGCallSubFcn("a5gqemnbab", ["&obj->OutputStream", "status_data", "status_size"], 0, 75, 2))>;
        if (!%<(SLibCGCallSubFcn("l1feuv03fpl", ["status_data", "status_size"], 0, 75, 1))>) {
            exitg1 = true;
        } else {
            guard1 = true;
        }
    } else {
        guard1 = true;
    }
    if (guard1) {
        count = 0.0;
        packetEndIndex = packetStartIndex;
        ii = 0;
        exitg2 = false;
        while ((!exitg2) && (ii <= (int32_T)((1.0 - packetStartIndex) + 1.0) - 1)) {
            success = c_p.size;
            c_p.size = 1;
            %<(SLibCGCallSubFcn("ekhc0cwc2a", ["&c_p.data", "&c_p.size", "success"], 0, 75, 5))>;
            %<(SLibCGCallSubFcn("fzkkuo0c5t", ["&c_p.data", "&c"], 0, 75, 3))>;
            success = coderOutputStreamWriteTypedDataOld(obj->OutputStream.StreamImpl, &countWrittenThisIteration, 1, "uint8", data->size[0] * data->size[1], &c_p.data.f1->data[0]);
            if (success == 0) {
                chImpl = coderStreamGetChannel(obj->OutputStream.StreamImpl);
                coderChannelHasSyncError(chImpl, &hasSyncError);
                if (!hasSyncError) {
                    coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
                } else {
                    coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
                }
            }
            if (countWrittenThisIteration == 0.0) {
                exitg2 = true;
            } else {
                count += countWrittenThisIteration;
                packetEndIndex++;
                ii++;
            }
        }
        countWritten += count;
        packetStartIndex = packetEndIndex;
    }
}
%<(SLibCGCallSubFcn("jv3xezhw0x", ["&c_p"], 0, 75, 9))>;
%<(SLibCGCallSubFcn("aqxvg4ncr3", ["&c"], 0, 75, 8))>;
obj->TotalElementsWritten += (real_T)data->size[0];
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void g1pihrrgkp(\
%assign comma = ""
%<comma>kw1nls53yo *obj\
%assign comma = ", "
%<comma>const ftbvbe5nvy *data\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 75, fcnProtoType)>
%return fcnBuff
%endfunction

%function kxnnwxsqki_Fcn76(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T e;
int32_T f;
int32_T i;
int32_T loop_ub;
int32_T loop_ub_p;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,76,1,0)
%<SLibCG_AccessArg(0 ,76, 3)>
%endif

%if SLibCG_FcnCallArgAccessed(0,76,0,0)
%<SLibCG_AccessArg(0 ,76, 3)>
%endif

if ((obj->PartialPacket->size[0] == 1) || (obj->PartialPacket->size[1] == 1)) {
    if (startIndex > endIndex) {
        f = 0;
        e = 0;
    } else {
        f = (int32_T)startIndex - 1;
        e = (int32_T)endIndex;
    }
    i = result->size[0] * result->size[1];
    result->size[0] = 1;
    result->size[1] = e - f;
    %<(SLibCGCallSubFcn("fptaaqsn5k", ["result", "i"], 0, 76, 1))>;
    loop_ub = e - f;
    for (e = 0; e < loop_ub; e++) {
        result->data[result->size[0] * e] = obj->PartialPacket->data[f + e];
    }
} else {
    if (startIndex > endIndex) {
        f = 0;
        e = 0;
    } else {
        f = (int32_T)startIndex - 1;
        e = (int32_T)endIndex;
    }
    i = result->size[0] * result->size[1];
    result->size[0] = obj->PartialPacket->size[0];
    result->size[1] = e - f;
    %<(SLibCGCallSubFcn("fptaaqsn5k", ["result", "i"], 0, 76, 0))>;
    loop_ub = e - f;
    for (e = 0; e < loop_ub; e++) {
        loop_ub_p = obj->PartialPacket->size[0];
        for (i = 0; i < loop_ub_p; i++) {
            result->data[i + result->size[0] * e] = obj->PartialPacket->data[(f + e) * obj->PartialPacket->size[0] + i];
        }
    }
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void kxnnwxsqki(\
%assign comma = ""
%<comma>const kw1nls53yo *obj\
%assign comma = ", "
%<comma>real_T startIndex\
%assign comma = ", "
%<comma>real_T endIndex\
%assign comma = ", "
%<comma>ftbvbe5nvy *result\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 76, fcnProtoType)>
%return fcnBuff
%endfunction

%function jvsizsb3rg_Fcn77(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
ftbvbe5nvy *tempDataRead;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,77,2,2)
%<SLibCG_AccessArg(0 ,77, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,77,1,0)
%<SLibCG_AccessArg(0 ,77, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,77,1,1)
%<SLibCG_AccessArg(0 ,77, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,77,1,2)
%<SLibCG_AccessArg(0 ,77, 0)>
%<SLibCG_AccessArg(0 ,77, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,77,0,0)
%<SLibCG_AccessArg(0 ,77, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,77,0,1)
%<SLibCG_AccessArg(0 ,77, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,77,0,2)
%<SLibCG_AccessArg(0 ,77, 0)>
%<SLibCG_AccessArg(0 ,77, 1)>
%endif

if (obj->PartialPacketCount > 0.0) {
    %<(SLibCGCallSubFcn("mw2mi4zvh2", ["&tempDataRead", "2"], 0, 77, 3))>;
    if (countRequested < obj->PartialPacketCount) {
        %<(SLibCGCallSubFcn("m0m3nyxjg4", ["obj->PartialPacket", "obj->PartialPacketStart", "(obj->PartialPacketStart + countRequested) - 1.0", "tempDataRead"], 0, 77, 0))>;
        *countRead = countRequested;
        obj->PartialPacketStart += countRequested;
        obj->PartialPacketCount -= countRequested;
    } else {
        %<(SLibCGCallSubFcn("m0m3nyxjg4", ["obj->PartialPacket", "obj->PartialPacketStart", "(obj->PartialPacketStart + obj->PartialPacketCount) - 1.0", "tempDataRead"], 0, 77, 1))>;
        *countRead = obj->PartialPacketCount;
        obj->PartialPacket->size[0] = obj->ExampleData->size[0];
        obj->PartialPacket->size[1] = 0;
        obj->PartialPacketStart = 0.0;
        obj->PartialPacketCount = 0.0;
    }
    %<(SLibCGCallSubFcn("m0m3nyxjg4a", ["tempDataRead", "(real_T)tempDataRead->size[1]", "dataRead"], 0, 77, 2))>;
    %<(SLibCGCallSubFcn("lv0yfzd1c2", ["&tempDataRead"], 0, 77, 4))>;
} else {
    dataRead->size[0] = 1;
    dataRead->size[1] = 0;
    *countRead = 0.0;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void jvsizsb3rg(\
%assign comma = ""
%<comma>i0lstc3zfv *obj\
%assign comma = ", "
%<comma>real_T countRequested\
%assign comma = ", "
%<comma>ftbvbe5nvy *dataRead\
%assign comma = ", "
%<comma>real_T *countRead\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 77, fcnProtoType)>
%return fcnBuff
%endfunction

%function a5gqemnbabo_Fcn78(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T et;
real_T startTic_tv_nsec;
real_T startTic_tv_sec;
real_T timeoutInSeconds;
int32_T i;
boolean_T completed;
boolean_T done;
boolean_T timeout;
static const char_T tmp[9] = %<(TLC_STR_CTX(35))>;
static const char_T tmp_p[7] = %<(TLC_STR_CTX(36))>;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,78,7,0)
%<SLibCG_AccessArg(0 ,78, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,78,6,0)
%<SLibCG_AccessArg(0 ,78, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,78,1,0)
%<SLibCG_AccessArg(0 ,78, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,78,0,0)
%<SLibCG_AccessArg(0 ,78, 0)>
%endif

timeoutInSeconds = obj->Timeout;
status_size[0] = 1;
status_size[1] = 0;
timeout = false;
done = false;
et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->StreamImpl"], 0, 78, 6))>;
completed = (et > 0.0);
%<(SLibCGCallSubFcn("i2ato1xcxyf", ["&startTic_tv_sec", "&startTic_tv_nsec"], 0, 78, 8))>;
while ((!completed) && (!done) && (!timeout)) {
    et = %<(SLibCGCallSubFcn("btyi2yuuqqr", ["startTic_tv_sec", "startTic_tv_nsec"], 0, 78, 2))>;
    if (et < 1.0) {
        %<(SLibCGCallSubFcn("jrnq5jhfee", ["0.0"], 0, 78, 5))>;
    } else {
        %<(SLibCGCallSubFcn("jrnq5jhfee", ["0.005"], 0, 78, 4))>;
    }
    et = %<(SLibCGCallSubFcn("btyi2yuuqqr", ["startTic_tv_sec", "startTic_tv_nsec"], 0, 78, 3))>;
    timeout = (et > timeoutInSeconds);
    if (%<(SLibCGCallSubFcn("k1scvijul4", ["obj"], 0, 78, 0))> || (!%<(SLibCGCallSubFcn("irhvzala2k", ["obj"], 0, 78, 1))>)) {
        done = true;
    }
    et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->StreamImpl"], 0, 78, 7))>;
    completed = (et > 0.0);
}
if (completed) {
    status_size[0] = 1;
    status_size[1] = 9;
    for (i = 0; i < 9; i++) {
        status_data[i] = tmp[i];
    }
} else if (done) {
    status_size[0] = 1;
    status_size[1] = 4;
    status_data[0] = 'd';
    status_data[1] = 'o';
    status_data[2] = 'n';
    status_data[3] = 'e';
} else if (timeout) {
    status_size[0] = 1;
    status_size[1] = 7;
    for (i = 0; i < 7; i++) {
        status_data[i] = tmp_p[i];
    }
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void a5gqemnbabo(\
%assign comma = ""
%<comma>const i0lstc3zfv *obj\
%assign comma = ", "
%<comma>char_T status_data[]\
%assign comma = ", "
%<comma>int32_T status_size[2]\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 78, fcnProtoType)>
%return fcnBuff
%endfunction

%function idaplsfg2k_Fcn79(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
ftbvbe5nvy *dataRead;
ftbvbe5nvy *dataRead_e;
ftbvbe5nvy *dataRead_i;
ftbvbe5nvy *dataRead_p;
ftbvbe5nvy *excessData;
mwbcmoqwkf *packets;
real_T b_countRead;
real_T count;
real_T count_p;
real_T remainingCount;
int32_T status_size[2];
int32_T d;
int32_T data_p;
int32_T err_size_idx_1;
int32_T exitg1;
int32_T i;
int32_T loop_ub;
char_T status_data[9];
boolean_T empty_non_axis_sizes;
boolean_T guard1;
boolean_T guard11;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,79,26,0)
%<SLibCG_AccessArg(0 ,79, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,25,0)
%<SLibCG_AccessArg(0 ,79, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,21,0)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,20,0)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,19,0)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,18,0)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,17,0)
%<SLibCG_AccessArg(0 ,79, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,16,0)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,14,0)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,13,0)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,12,0)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,79,12,1)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,79,12,2)
%<SLibCG_AccessArg(0 ,79, 0)>
%<SLibCG_AccessArg(0 ,79, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,11,0)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,79,11,1)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,79,11,2)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,10,0)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,9,0)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,5,0)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,4,0)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,79,4,1)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,79,4,2)
%<SLibCG_AccessArg(0 ,79, 0)>
%<SLibCG_AccessArg(0 ,79, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,79,3,0)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,79,3,1)
%<SLibCG_AccessArg(0 ,79, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,79,3,2)
%<SLibCG_AccessArg(0 ,79, 0)>
%<SLibCG_AccessArg(0 ,79, 1)>
%endif

if (numBytesToRead == 0.0) {
    data->size[0] = 0;
    data->size[1] = 0;
} else {
    %<(SLibCGCallSubFcn("mw2mi4zvh2", ["&dataRead", "2"], 0, 79, 27))>;
    if (obj->PartialPacketCount > 0.0) {
        if (numBytesToRead < obj->PartialPacketCount) {
            %<(SLibCGCallSubFcn("kxnnwxsqki", ["obj", "obj->PartialPacketStart", "(obj->PartialPacketStart + numBytesToRead) - 1.0", "dataRead"], 0, 79, 3))>;
            remainingCount = numBytesToRead;
            obj->PartialPacketStart += numBytesToRead;
            obj->PartialPacketCount -= numBytesToRead;
        } else {
            %<(SLibCGCallSubFcn("kxnnwxsqki", ["obj", "obj->PartialPacketStart", "(obj->PartialPacketStart + obj->PartialPacketCount) - 1.0", "dataRead"], 0, 79, 4))>;
            remainingCount = obj->PartialPacketCount;
            obj->PartialPacket->size[0] = 1;
            obj->PartialPacket->size[1] = 0;
            obj->PartialPacket->size[0] = 0;
            obj->PartialPacket->size[1] = 0;
            obj->PartialPacketStart = 0.0;
            obj->PartialPacketCount = 0.0;
        }
    } else {
        dataRead->size[0] = 0;
        dataRead->size[1] = 0;
        remainingCount = 0.0;
    }
    remainingCount = numBytesToRead - remainingCount;
    if (remainingCount > 0.0) {
        %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->InputStream.StreamImpl"], 0, 79, 13))>;
        count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->InputStream.StreamImpl"], 0, 79, 14))>;
        count += obj->InputStream.PartialPacketCount;
        i = obj->InputStream.ExampleData->size[0] * obj->InputStream.ExampleData->size[1];
        obj->InputStream.ExampleData->size[0] = 1;
        obj->InputStream.ExampleData->size[1] = 1;
        %<(SLibCGCallSubFcn("fptaaqsn5k", ["obj->InputStream.ExampleData", "i"], 0, 79, 18))>;
        obj->InputStream.ExampleData->data[0] = 0U;
        err_size_idx_1 = 0;
        %<(SLibCGCallSubFcn("mw2mi4zvh2", ["&dataRead_p", "2"], 0, 79, 28))>;
        %<(SLibCGCallSubFcn("jvsizsb3rg", ["&obj->InputStream", "count", "dataRead_p", "&b_countRead"], 0, 79, 9))>;
        %<(SLibCGCallSubFcn("mw2mi4zvh2", ["&excessData", "2"], 0, 79, 29))>;
        if (b_countRead == count) {
            %<(SLibCGCallSubFcn("m0m3nyxjg4a", ["dataRead_p", "(real_T)dataRead_p->size[1]", "excessData"], 0, 79, 15))>;
        } else {
            %<(SLibCGCallSubFcn("ol04rdb3hp", ["&packets", "2"], 0, 79, 30))>;
            %<(SLibCGCallSubFcn("mw2mi4zvh2", ["&dataRead_e", "2"], 0, 79, 31))>;
            %<(SLibCGCallSubFcn("mw2mi4zvh2", ["&dataRead_i", "2"], 0, 79, 32))>;
            guard1 = false;
            do {
                exitg1 = 0;
                if (b_countRead < count) {
                    count_p = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->InputStream.StreamImpl"], 0, 79, 16))>;
                    guard11 = false;
                    if (count_p == 0.0) {
                        %<(SLibCGCallSubFcn("a5gqemnbabo", ["&obj->InputStream", "status_data", "status_size"], 0, 79, 5))>;
                        if (!%<(SLibCGCallSubFcn("l1feuv03fpl", ["status_data", "status_size"], 0, 79, 0))>) {
                            err_size_idx_1 = status_size[1];
                            if (%<(SLibCGCallSubFcn("l1feuv03fple", ["status_data", "status_size"], 0, 79, 1))>) {
                                excessData->size[0] = 1;
                                excessData->size[1] = 0;
                            } else {
                                if (%<(SLibCGCallSubFcn("l1feuv03fpleo", ["status_data", "status_size"], 0, 79, 2))>) {
                                    err_size_idx_1 = 0;
                                }
                                guard1 = true;
                            }
                            exitg1 = 1;
                        } else {
                            guard11 = true;
                        }
                    } else {
                        guard11 = true;
                    }
                    if (guard11) {
                        %<(SLibCGCallSubFcn("fln1whbkdj", ["&obj->InputStream", "count - b_countRead", "packets", "&count_p"], 0, 79, 10))>;
                        d = packets->size[1];
                        for (data_p = 0; data_p < d; data_p++) {
                            i = dataRead_i->size[0] * dataRead_i->size[1];
                            dataRead_i->size[0] = dataRead_p->size[0];
                            dataRead_i->size[1] = dataRead_p->size[1];
                            %<(SLibCGCallSubFcn("fptaaqsn5k", ["dataRead_i", "i"], 0, 79, 23))>;
                            loop_ub = dataRead_p->size[0] * dataRead_p->size[1] - 1;
                            if (loop_ub >= 0) {
                                memcpy(&dataRead_i->data[0], &dataRead_p->data[0], (uint32_T)(loop_ub + 1) * sizeof(uint8_T));
                            }
                            %<(SLibCGCallSubFcn("gs0i0ykog4", ["dataRead_i", "packets->data[data_p].f1", "dataRead_p"], 0, 79, 6))>;
                        }
                        b_countRead += count_p;
                        guard1 = false;
                    }
                } else {
                    guard1 = true;
                    exitg1 = 1;
                }
            } while (exitg1 == 0);
            if (guard1) {
                if (b_countRead > count) {
                    %<(SLibCGCallSubFcn("m0m3nyxjg4", ["dataRead_p", "count + 1.0", "b_countRead", "excessData"], 0, 79, 7))>;
                    i = obj->InputStream.PartialPacket->size[0] * obj->InputStream.PartialPacket->size[1];
                    obj->InputStream.PartialPacket->size[0] = excessData->size[0];
                    obj->InputStream.PartialPacket->size[1] = excessData->size[1];
                    %<(SLibCGCallSubFcn("fptaaqsn5k", ["obj->InputStream.PartialPacket", "i"], 0, 79, 19))>;
                    loop_ub = excessData->size[0] * excessData->size[1];
                    for (i = 0; i < loop_ub; i++) {
                        obj->InputStream.PartialPacket->data[i] = excessData->data[i];
                    }
                    obj->InputStream.PartialPacketStart = 1.0;
                    obj->InputStream.PartialPacketCount = excessData->size[1];
                    i = dataRead_e->size[0] * dataRead_e->size[1];
                    dataRead_e->size[0] = dataRead_p->size[0];
                    dataRead_e->size[1] = dataRead_p->size[1];
                    %<(SLibCGCallSubFcn("fptaaqsn5k", ["dataRead_e", "i"], 0, 79, 24))>;
                    loop_ub = dataRead_p->size[0] * dataRead_p->size[1] - 1;
                    if (loop_ub >= 0) {
                        memcpy(&dataRead_e->data[0], &dataRead_p->data[0], (uint32_T)(loop_ub + 1) * sizeof(uint8_T));
                    }
                    %<(SLibCGCallSubFcn("m0m3nyxjg4a", ["dataRead_e", "count", "dataRead_p"], 0, 79, 8))>;
                }
                if (err_size_idx_1 != 0) {
                    i = obj->InputStream.PartialPacket->size[0] * obj->InputStream.PartialPacket->size[1];
                    obj->InputStream.PartialPacket->size[0] = dataRead_p->size[0];
                    obj->InputStream.PartialPacket->size[1] = dataRead_p->size[1];
                    %<(SLibCGCallSubFcn("fptaaqsn5k", ["obj->InputStream.PartialPacket", "i"], 0, 79, 21))>;
                    loop_ub = dataRead_p->size[0] * dataRead_p->size[1];
                    for (i = 0; i < loop_ub; i++) {
                        obj->InputStream.PartialPacket->data[i] = dataRead_p->data[i];
                    }
                    obj->InputStream.PartialPacketStart = 1.0;
                    obj->InputStream.PartialPacketCount = dataRead_p->size[1];
                    excessData->size[0] = 1;
                    excessData->size[1] = 0;
                } else {
                    i = excessData->size[0] * excessData->size[1];
                    excessData->size[0] = dataRead_p->size[0];
                    excessData->size[1] = dataRead_p->size[1];
                    %<(SLibCGCallSubFcn("fptaaqsn5k", ["excessData", "i"], 0, 79, 22))>;
                    loop_ub = dataRead_p->size[0] * dataRead_p->size[1];
                    if (loop_ub - 1 >= 0) {
                        memcpy(&excessData->data[0], &dataRead_p->data[0], (uint32_T)loop_ub * sizeof(uint8_T));
                    }
                }
            }
            %<(SLibCGCallSubFcn("lv0yfzd1c2", ["&dataRead_i"], 0, 79, 38))>;
            %<(SLibCGCallSubFcn("lv0yfzd1c2", ["&dataRead_e"], 0, 79, 37))>;
            %<(SLibCGCallSubFcn("o55ouaau02", ["&packets"], 0, 79, 36))>;
        }
        %<(SLibCGCallSubFcn("lv0yfzd1c2", ["&dataRead_p"], 0, 79, 34))>;
        if (remainingCount < excessData->size[1]) {
            i = obj->PartialPacket->size[0] * obj->PartialPacket->size[1];
            obj->PartialPacket->size[0] = 1;
            obj->PartialPacket->size[1] = 0;
            obj->PartialPacket->size[0] = excessData->size[0];
            obj->PartialPacket->size[1] = excessData->size[1];
            %<(SLibCGCallSubFcn("fptaaqsn5k", ["obj->PartialPacket", "i"], 0, 79, 20))>;
            loop_ub = excessData->size[0] * excessData->size[1];
            for (i = 0; i < loop_ub; i++) {
                obj->PartialPacket->data[i] = excessData->data[i];
            }
            obj->PartialPacketStart = 1.0;
            obj->PartialPacketCount = excessData->size[1];
            if (obj->PartialPacketCount > 0.0) {
                if (remainingCount < obj->PartialPacketCount) {
                    %<(SLibCGCallSubFcn("kxnnwxsqki", ["obj", "obj->PartialPacketStart", "(obj->PartialPacketStart + remainingCount) - 1.0", "excessData"], 0, 79, 11))>;
                    obj->PartialPacketStart += remainingCount;
                    obj->PartialPacketCount -= remainingCount;
                } else {
                    %<(SLibCGCallSubFcn("kxnnwxsqki", ["obj", "obj->PartialPacketStart", "(obj->PartialPacketStart + obj->PartialPacketCount) - 1.0", "excessData"], 0, 79, 12))>;
                    obj->PartialPacket->size[0] = 1;
                    obj->PartialPacket->size[1] = 0;
                    obj->PartialPacket->size[0] = 0;
                    obj->PartialPacket->size[1] = 0;
                    obj->PartialPacketStart = 0.0;
                    obj->PartialPacketCount = 0.0;
                }
            } else {
                excessData->size[0] = 0;
                excessData->size[1] = 0;
            }
            if ((dataRead->size[0] != 0) && (dataRead->size[1] != 0)) {
                data_p = dataRead->size[0];
            } else if ((excessData->size[0] != 0) && (excessData->size[1] != 0)) {
                data_p = excessData->size[0];
            } else {
                data_p = dataRead->size[0];
                if (excessData->size[0] > dataRead->size[0]) {
                    data_p = excessData->size[0];
                }
            }
            empty_non_axis_sizes = (data_p == 0);
            if (empty_non_axis_sizes || ((dataRead->size[0] != 0) && (dataRead->size[1] != 0))) {
                d = dataRead->size[1];
            } else {
                d = 0;
            }
            if (empty_non_axis_sizes || ((excessData->size[0] != 0) && (excessData->size[1] != 0))) {
                err_size_idx_1 = excessData->size[1];
            } else {
                err_size_idx_1 = 0;
            }
            i = data->size[0] * data->size[1];
            data->size[0] = data_p;
            data->size[1] = d + err_size_idx_1;
            %<(SLibCGCallSubFcn("fptaaqsn5k", ["data", "i"], 0, 79, 26))>;
            loop_ub = data_p * d;
            if (loop_ub - 1 >= 0) {
                memcpy(&data->data[0], &dataRead->data[0], (uint32_T)loop_ub * sizeof(uint8_T));
            }
            loop_ub = data_p * err_size_idx_1;
            for (i = 0; i < loop_ub; i++) {
                data->data[i + data_p * d] = excessData->data[i];
            }
        } else {
            if ((dataRead->size[0] != 0) && (dataRead->size[1] != 0)) {
                data_p = dataRead->size[0];
            } else if ((excessData->size[0] != 0) && (excessData->size[1] != 0)) {
                data_p = excessData->size[0];
            } else {
                data_p = dataRead->size[0];
                if (excessData->size[0] > dataRead->size[0]) {
                    data_p = excessData->size[0];
                }
            }
            empty_non_axis_sizes = (data_p == 0);
            if (empty_non_axis_sizes || ((dataRead->size[0] != 0) && (dataRead->size[1] != 0))) {
                d = dataRead->size[1];
            } else {
                d = 0;
            }
            if (empty_non_axis_sizes || ((excessData->size[0] != 0) && (excessData->size[1] != 0))) {
                err_size_idx_1 = excessData->size[1];
            } else {
                err_size_idx_1 = 0;
            }
            i = data->size[0] * data->size[1];
            data->size[0] = data_p;
            data->size[1] = d + err_size_idx_1;
            %<(SLibCGCallSubFcn("fptaaqsn5k", ["data", "i"], 0, 79, 25))>;
            loop_ub = data_p * d;
            if (loop_ub - 1 >= 0) {
                memcpy(&data->data[0], &dataRead->data[0], (uint32_T)loop_ub * sizeof(uint8_T));
            }
            loop_ub = data_p * err_size_idx_1;
            for (i = 0; i < loop_ub; i++) {
                data->data[i + data_p * d] = excessData->data[i];
            }
        }
        %<(SLibCGCallSubFcn("lv0yfzd1c2", ["&excessData"], 0, 79, 35))>;
    } else {
        i = data->size[0] * data->size[1];
        data->size[0] = dataRead->size[0];
        data->size[1] = dataRead->size[1];
        %<(SLibCGCallSubFcn("fptaaqsn5k", ["data", "i"], 0, 79, 17))>;
        loop_ub = dataRead->size[0] * dataRead->size[1];
        if (loop_ub - 1 >= 0) {
            memcpy(&data->data[0], &dataRead->data[0], (uint32_T)loop_ub * sizeof(uint8_T));
        }
    }
    %<(SLibCGCallSubFcn("lv0yfzd1c2", ["&dataRead"], 0, 79, 33))>;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void idaplsfg2k(\
%assign comma = ""
%<comma>kw1nls53yo *obj\
%assign comma = ", "
%<comma>real_T numBytesToRead\
%assign comma = ", "
%<comma>ftbvbe5nvy *data\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 79, fcnProtoType)>
%return fcnBuff
%endfunction

%function nvhcqcdzap_Fcn80(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
int32_T newNumel;
void *newData;
if (oldNumel < 0) {
    oldNumel = 0;
}
newNumel = 1;
for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel *= emxArray->size[i];
}
if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
        i = 16;
    }
    while (i < newNumel) {
        if (i > 1073741823) {
            i = MAX_int32_T;
        } else {
            i <<= 1;
        }
    }
    newData = malloc((uint32_T)i * sizeof(int32_T));
    if (emxArray->data != NULL) {
        memcpy(newData, emxArray->data, sizeof(int32_T) * (uint32_T)oldNumel);
        if (emxArray->canFreeData) {
            free(emxArray->data);
        }
    }
    emxArray->data = (int32_T *)newData;
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void nvhcqcdzap(\
%assign comma = ""
%<comma>he1ich2doy *emxArray\
%assign comma = ", "
%<comma>int32_T oldNumel\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 80, fcnProtoType)>
%return fcnBuff
%endfunction

%function hndnmfdyav_Fcn81(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
int32_T newNumel;
void *newData;
if (oldNumel < 0) {
    oldNumel = 0;
}
newNumel = 1;
for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel *= emxArray->size[i];
}
if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
        i = 16;
    }
    while (i < newNumel) {
        if (i > 1073741823) {
            i = MAX_int32_T;
        } else {
            i <<= 1;
        }
    }
    newData = malloc((uint32_T)i * sizeof(real_T));
    if (emxArray->data != NULL) {
        memcpy(newData, emxArray->data, sizeof(real_T) * (uint32_T)oldNumel);
        if (emxArray->canFreeData) {
            free(emxArray->data);
        }
    }
    emxArray->data = (real_T *)newData;
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void hndnmfdyav(\
%assign comma = ""
%<comma>i3054vb1je *emxArray\
%assign comma = ", "
%<comma>int32_T oldNumel\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 81, fcnProtoType)>
%return fcnBuff
%endfunction

%function ptt1gjr52i_Fcn82(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
if (*pEmxArray != (he1ich2doy *)NULL) {
    if (((*pEmxArray)->data != (int32_T *)NULL) && (*pEmxArray)->canFreeData) {
        free((*pEmxArray)->data);
    }
    free((*pEmxArray)->size);
    free(*pEmxArray);
    *pEmxArray = (he1ich2doy *)NULL;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void ptt1gjr52i(\
%assign comma = ""
%<comma>he1ich2doy **pEmxArray\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 82, fcnProtoType)>
%return fcnBuff
%endfunction

%function of42omp0rq_Fcn83(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
if (*pEmxArray != (i3054vb1je *)NULL) {
    if (((*pEmxArray)->data != (real_T *)NULL) && (*pEmxArray)->canFreeData) {
        free((*pEmxArray)->data);
    }
    free((*pEmxArray)->size);
    free(*pEmxArray);
    *pEmxArray = (i3054vb1je *)NULL;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void of42omp0rq(\
%assign comma = ""
%<comma>i3054vb1je **pEmxArray\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 83, fcnProtoType)>
%return fcnBuff
%endfunction

%function hntjzegkkl_Fcn84(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T count;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,84,2,0)
%<SLibCG_AccessArg(0 ,84, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,84,1,0)
%<SLibCG_AccessArg(0 ,84, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,84,0,0)
%<SLibCG_AccessArg(0 ,84, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,84,0,1)
%<SLibCG_AccessArg(0 ,84, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,84,0,2)
%<SLibCG_AccessArg(0 ,84, 1)>
%endif

count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->UnreadDataBuffer.InputStream.StreamImpl"], 0, 84, 1))>;
if (((obj->UnreadDataBuffer.InputStream.PartialPacketCount + count) + obj->UnreadDataBuffer.PartialPacketCount) / obj->UnreadDataBuffer.BytesPerElement != 0.0) {
    count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->UnreadDataBuffer.InputStream.StreamImpl"], 0, 84, 2))>;
    count = ((obj->UnreadDataBuffer.InputStream.PartialPacketCount + count) + obj->UnreadDataBuffer.PartialPacketCount) / obj->UnreadDataBuffer.BytesPerElement;
    if (count == 0.0) {
        data->size[0] = 0;
        data->size[1] = 0;
    } else {
        %<(SLibCGCallSubFcn("idaplsfg2k", ["&obj->UnreadDataBuffer", "count * obj->UnreadDataBuffer.BytesPerElement", "data"], 0, 84, 0))>;
    }
} else {
    data->size[0] = 0;
    data->size[1] = 0;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void hntjzegkkl(\
%assign comma = ""
%<comma>habembxjyg *obj\
%assign comma = ", "
%<comma>ftbvbe5nvy *data\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 84, fcnProtoType)>
%return fcnBuff
%endfunction

%function jvoxagkxq2_Fcn85(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
pEmxArray->size = 0;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void jvoxagkxq2(\
%assign comma = ""
%<comma>l3jp1aacav *pEmxArray\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 85, fcnProtoType)>
%return fcnBuff
%endfunction

%function j1jq5djczg_Fcn86(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,86,0,0)
%<SLibCG_AccessArg(0 ,86, 0)>
%endif

for (i = fromIndex; i < toIndex; i++) {
    %<(SLibCGCallSubFcn("mem3fxtxvs", ["data"], 0, 86, 0))>;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void j1jq5djczg(\
%assign comma = ""
%<comma>fdfwht03ld *data\
%assign comma = ", "
%<comma>int32_T fromIndex\
%assign comma = ", "
%<comma>int32_T toIndex\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 86, fcnProtoType)>
%return fcnBuff
%endfunction

%function jrwscpnbky_Fcn87(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,87,0,0)
%<SLibCG_AccessArg(0 ,87, 0)>
%endif

for (i = fromIndex; i < toIndex; i++) {
    %<(SLibCGCallSubFcn("hgyje4smkq", ["data"], 0, 87, 0))>;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void jrwscpnbky(\
%assign comma = ""
%<comma>fdfwht03ld *data\
%assign comma = ", "
%<comma>int32_T fromIndex\
%assign comma = ", "
%<comma>int32_T toIndex\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 87, fcnProtoType)>
%return fcnBuff
%endfunction

%function fsydf40k4y_Fcn88(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T newNumel;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,88,1,0)
%<SLibCG_AccessArg(0 ,88, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,88,1,1)
%<SLibCG_AccessArg(0 ,88, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,88,0,0)
%<SLibCG_AccessArg(0 ,88, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,88,0,2)
%<SLibCG_AccessArg(0 ,88, 2)>
%endif

if (oldNumel < 0) {
    oldNumel = 0;
}
newNumel = *size;
if (oldNumel > newNumel) {
    %<(SLibCGCallSubFcn("jrwscpnbky", ["data", "newNumel", "oldNumel"], 0, 88, 0))>;
} else if (oldNumel < newNumel) {
    %<(SLibCGCallSubFcn("j1jq5djczg", ["data", "oldNumel", "newNumel"], 0, 88, 1))>;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void fsydf40k4y(\
%assign comma = ""
%<comma>fdfwht03ld *data\
%assign comma = ", "
%<comma>const int32_T *size\
%assign comma = ", "
%<comma>int32_T oldNumel\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 88, fcnProtoType)>
%return fcnBuff
%endfunction

%function iq50fnfmt4_Fcn89(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,89,0,0)
%<SLibCG_AccessArg(0 ,89, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,89,0,1)
%<SLibCG_AccessArg(0 ,89, 1)>
%endif

%<(SLibCGCallSubFcn("h2txudbtwt", ["&dst->f1", "&src->f1"], 0, 89, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void iq50fnfmt4(\
%assign comma = ""
%<comma>fdfwht03ld *dst\
%assign comma = ", "
%<comma>const fdfwht03ld *src\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 89, fcnProtoType)>
%return fcnBuff
%endfunction

%function eeo5axlb2h_Fcn90(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
int32_T numEl;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,90,0,0)
%<SLibCG_AccessArg(0 ,90, 0)>
%endif

numEl = 1;
for (i = 0; i < 1; i++) {
    numEl *= pEmxArray->size;
}
for (i = 0; i < numEl; i++) {
    %<(SLibCGCallSubFcn("hgyje4smkq", ["&pEmxArray->data"], 0, 90, 0))>;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void eeo5axlb2h(\
%assign comma = ""
%<comma>l3jp1aacav *pEmxArray\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 90, fcnProtoType)>
%return fcnBuff
%endfunction

%function g1pihrrgkpd_Fcn91(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
fdfwht03ld c;
l3jp1aacav c_p;
real_T count;
real_T countWritten;
real_T countWrittenThisIteration;
real_T packetEndIndex;
real_T packetStartIndex;
int32_T status_size[2];
int32_T ii;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
char_T status_data[9];
boolean_T exitg1;
boolean_T exitg2;
boolean_T guard1;
boolean_T hasSyncError;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,91,2,0)
%<SLibCG_AccessArg(0 ,91, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,91,0,0)
%<SLibCG_AccessArg(0 ,91, 0)>
%endif

obj->BytesPerElement = 1.0;
countWritten = 0.0;
%<(SLibCGCallSubFcn("mem3fxtxvs", ["&c"], 0, 91, 6))>;
success = c.f1->size[0] * c.f1->size[1];
c.f1->size[0] = 1;
c.f1->size[1] = data->size[1];
%<(SLibCGCallSubFcn("fptaaqsn5k", ["c.f1", "success"], 0, 91, 4))>;
success = data->size[1];
for (ii = 0; ii < success; ii++) {
    c.f1->data[ii] = data->data[ii];
}
packetStartIndex = 1.0;
%<(SLibCGCallSubFcn("jvoxagkxq2", ["&c_p"], 0, 91, 7))>;
exitg1 = false;
while ((!exitg1) && (countWritten < data->size[1])) {
    guard1 = false;
    if (%<(SLibCGCallSubFcn("cqil0vzmra", ["&obj->OutputStream"], 0, 91, 0))> == 0.0) {
        %<(SLibCGCallSubFcn("a5gqemnbab", ["&obj->OutputStream", "status_data", "status_size"], 0, 91, 2))>;
        if (!%<(SLibCGCallSubFcn("l1feuv03fpl", ["status_data", "status_size"], 0, 91, 1))>) {
            exitg1 = true;
        } else {
            guard1 = true;
        }
    } else {
        guard1 = true;
    }
    if (guard1) {
        count = 0.0;
        packetEndIndex = packetStartIndex;
        ii = 0;
        exitg2 = false;
        while ((!exitg2) && (ii <= (int32_T)((1.0 - packetStartIndex) + 1.0) - 1)) {
            success = c_p.size;
            c_p.size = 1;
            %<(SLibCGCallSubFcn("fsydf40k4y", ["&c_p.data", "&c_p.size", "success"], 0, 91, 5))>;
            %<(SLibCGCallSubFcn("iq50fnfmt4", ["&c_p.data", "&c"], 0, 91, 3))>;
            success = coderOutputStreamWriteTypedDataOld(obj->OutputStream.StreamImpl, &countWrittenThisIteration, 1, "uint8", data->size[1], &c_p.data.f1->data[0]);
            if (success == 0) {
                chImpl = coderStreamGetChannel(obj->OutputStream.StreamImpl);
                coderChannelHasSyncError(chImpl, &hasSyncError);
                if (!hasSyncError) {
                    coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
                } else {
                    coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
                }
            }
            if (countWrittenThisIteration == 0.0) {
                exitg2 = true;
            } else {
                count += countWrittenThisIteration;
                packetEndIndex++;
                ii++;
            }
        }
        countWritten += count;
        packetStartIndex = packetEndIndex;
    }
}
%<(SLibCGCallSubFcn("eeo5axlb2h", ["&c_p"], 0, 91, 9))>;
%<(SLibCGCallSubFcn("hgyje4smkq", ["&c"], 0, 91, 8))>;
obj->TotalElementsWritten++;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void g1pihrrgkpd(\
%assign comma = ""
%<comma>kw1nls53yo *obj\
%assign comma = ", "
%<comma>const ftbvbe5nvy *data\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 91, fcnProtoType)>
%return fcnBuff
%endfunction

%function grofjyw12k_Fcn92(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
ftbvbe5nvy *searchData;
ftbvbe5nvy *searchData_p;
he1ich2doy *match_out;
he1ich2doy *matches;
hgyzgm1py1 *searchDataChar;
i0lstc3zfv *obj_p;
real_T a__3;
real_T et;
real_T startTic_tv_nsec;
real_T startTic_tv_nsec_p;
real_T startTic_tv_sec;
real_T timeoutInSeconds;
int32_T status_size[2];
int32_T b_idx_0;
int32_T match_idx;
int32_T text_len;
int32_T tmp;
char_T status_data[9];
boolean_T completed;
boolean_T done;
boolean_T guard1;
boolean_T tokenFound;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,92,38,0)
%<SLibCG_AccessArg(0 ,92, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,92,32,0)
%<SLibCG_AccessArg(0 ,92, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,92,27,0)
%<SLibCG_AccessArg(0 ,92, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,92,26,0)
%<SLibCG_AccessArg(0 ,92, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,92,25,0)
%<SLibCG_AccessArg(0 ,92, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,92,25,1)
%<SLibCG_AccessArg(0 ,92, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,92,24,0)
%<SLibCG_AccessArg(0 ,92, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,92,23,0)
%<SLibCG_AccessArg(0 ,92, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,92,22,0)
%<SLibCG_AccessArg(0 ,92, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,92,21,0)
%<SLibCG_AccessArg(0 ,92, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,92,7,0)
%<SLibCG_AccessArg(0 ,92, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,92,6,0)
%<SLibCG_AccessArg(0 ,92, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,92,5,0)
%<SLibCG_AccessArg(0 ,92, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,92,4,0)
%<SLibCG_AccessArg(0 ,92, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,92,3,0)
%<SLibCG_AccessArg(0 ,92, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,92,2,0)
%<SLibCG_AccessArg(0 ,92, 0)>
%endif

data->size[0] = 1;
data->size[1] = 0;
tokenFound = false;
obj_p = &obj->AsyncIOChannel->InputStream;
et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj_p->StreamImpl"], 0, 92, 0))>;
et += obj_p->PartialPacketCount;
%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&searchData", "2"], 0, 92, 41))>;
if (et > 0.0) {
    obj_p = &obj->AsyncIOChannel->InputStream;
    et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj_p->StreamImpl"], 0, 92, 1))>;
    et += obj_p->PartialPacketCount;
    %<(SLibCGCallSubFcn("d1cnfcxsqs", ["&obj->AsyncIOChannel->InputStream", "et", "searchData", "&a__3", "status_data", "status_size"], 0, 92, 2))>;
    %<(SLibCGCallSubFcn("g1pihrrgkp", ["&obj->UnreadDataBuffer", "searchData"], 0, 92, 3))>;
}
et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->UnreadDataBuffer.InputStream.StreamImpl"], 0, 92, 4))>;
et += obj->UnreadDataBuffer.InputStream.PartialPacketCount;
et += obj->UnreadDataBuffer.PartialPacketCount;
et /= obj->UnreadDataBuffer.BytesPerElement;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&searchDataChar", "2"], 0, 92, 42))>;
%<(SLibCGCallSubFcn("iv4amyl51q", ["&match_out", "2"], 0, 92, 43))>;
%<(SLibCGCallSubFcn("iv4amyl51q", ["&matches", "2"], 0, 92, 44))>;
%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&searchData_p", "2"], 0, 92, 45))>;
guard1 = false;
if (et != 0.0) {
    %<(SLibCGCallSubFcn("hntjzegkkl", ["obj", "searchData"], 0, 92, 5))>;
    tmp = searchDataChar->size[0] * searchDataChar->size[1];
    searchDataChar->size[0] = searchData->size[0];
    searchDataChar->size[1] = searchData->size[1];
    %<(SLibCGCallSubFcn("kt1e3yths5", ["searchDataChar", "tmp"], 0, 92, 29))>;
    match_idx = searchData->size[0] * searchData->size[1];
    for (text_len = 0; text_len < match_idx; text_len++) {
        searchDataChar->data[text_len] = (int8_T)searchData->data[text_len];
    }
    if ((searchDataChar->size[0] == 0) || (searchDataChar->size[1] == 0)) {
        matches->size[0] = 1;
        matches->size[1] = 0;
    } else {
        text_len = searchDataChar->size[0] * searchDataChar->size[1];
        tmp = matches->size[0] * matches->size[1];
        matches->size[0] = 1;
        matches->size[1] = text_len;
        %<(SLibCGCallSubFcn("nvhcqcdzap", ["matches", "tmp"], 0, 92, 30))>;
        match_idx = 0;
        for (b_idx_0 = 0; b_idx_0 < text_len; b_idx_0++) {
            if (searchDataChar->data[b_idx_0] == 'S') {
                matches->data[match_idx] = b_idx_0 + 1;
                match_idx++;
            }
        }
        tmp = match_out->size[0] * match_out->size[1];
        match_out->size[0] = 1;
        match_out->size[1] = match_idx;
        %<(SLibCGCallSubFcn("nvhcqcdzap", ["match_out", "tmp"], 0, 92, 31))>;
        if (match_idx - 1 >= 0) {
            memcpy(&match_out->data[0], &matches->data[0], (uint32_T)match_idx * sizeof(int32_T));
        }
        tmp = matches->size[0] * matches->size[1];
        matches->size[0] = 1;
        matches->size[1] = match_out->size[1];
        %<(SLibCGCallSubFcn("nvhcqcdzap", ["matches", "tmp"], 0, 92, 33))>;
        match_idx = match_out->size[1];
        if (match_idx - 1 >= 0) {
            memcpy(&matches->data[0], &match_out->data[0], (uint32_T)match_idx * sizeof(int32_T));
        }
    }
    if (matches->size[1] != 0) {
        match_idx = (int32_T)(((real_T)matches->data[0] + 1.0) - 1.0);
        tmp = data->size[0] * data->size[1];
        data->size[0] = 1;
        data->size[1] = match_idx;
        %<(SLibCGCallSubFcn("fptaaqsn5k", ["data", "tmp"], 0, 92, 32))>;
        if (match_idx - 1 >= 0) {
            memcpy(&data->data[0], &searchData->data[0], (uint32_T)match_idx * sizeof(uint8_T));
        }
        if ((searchData->size[0] == 0) || (searchData->size[1] == 0)) {
            b_idx_0 = 0;
        } else {
            text_len = searchData->size[0];
            b_idx_0 = searchData->size[1];
            b_idx_0 = muIntScalarMax_sint32(text_len, b_idx_0);
        }
        if ((int32_T)(((real_T)matches->data[0] + 1.0) - 1.0) < b_idx_0) {
            et = searchData->size[0] * searchData->size[1];
            if ((((real_T)matches->data[0] + 1.0) - 1.0) + 1.0 > et) {
                b_idx_0 = 0;
                text_len = 0;
            } else {
                b_idx_0 = (int32_T)(((real_T)matches->data[0] + 1.0) - 1.0);
                text_len = (int32_T)et;
            }
            tmp = searchData_p->size[0] * searchData_p->size[1];
            searchData_p->size[0] = 1;
            searchData_p->size[1] = text_len - b_idx_0;
            %<(SLibCGCallSubFcn("fptaaqsn5k", ["searchData_p", "tmp"], 0, 92, 35))>;
            match_idx = text_len - b_idx_0;
            for (text_len = 0; text_len < match_idx; text_len++) {
                searchData_p->data[text_len] = searchData->data[b_idx_0 + text_len];
            }
            %<(SLibCGCallSubFcn("g1pihrrgkpd", ["&obj->UnreadDataBuffer", "searchData_p"], 0, 92, 6))>;
        }
    } else {
        %<(SLibCGCallSubFcn("g1pihrrgkp", ["&obj->UnreadDataBuffer", "searchData"], 0, 92, 7))>;
        guard1 = true;
    }
} else {
    guard1 = true;
}
if (guard1) {
    %<(SLibCGCallSubFcn("i2ato1xcxyf", ["&a__3", "&startTic_tv_nsec"], 0, 92, 8))>;
    while (!tokenFound) {
        obj_p = &obj->AsyncIOChannel->InputStream;
        et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj_p->StreamImpl"], 0, 92, 9))>;
        et += obj_p->PartialPacketCount;
        if (!(et != 0.0)) {
            obj_p = &obj->AsyncIOChannel->InputStream;
            timeoutInSeconds = obj_p->Timeout;
            done = false;
            et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj_p->StreamImpl"], 0, 92, 10))>;
            et += obj_p->PartialPacketCount;
            completed = (et > 0.0);
            %<(SLibCGCallSubFcn("i2ato1xcxyf", ["&startTic_tv_sec", "&startTic_tv_nsec_p"], 0, 92, 11))>;
            while ((!completed) && (!done) && (!tokenFound)) {
                et = %<(SLibCGCallSubFcn("btyi2yuuqqr", ["startTic_tv_sec", "startTic_tv_nsec_p"], 0, 92, 12))>;
                if (et < 1.0) {
                    %<(SLibCGCallSubFcn("jrnq5jhfee", ["0.0"], 0, 92, 13))>;
                } else {
                    %<(SLibCGCallSubFcn("jrnq5jhfee", ["0.005"], 0, 92, 14))>;
                }
                et = %<(SLibCGCallSubFcn("btyi2yuuqqr", ["startTic_tv_sec", "startTic_tv_nsec_p"], 0, 92, 15))>;
                tokenFound = (et > timeoutInSeconds);
                if (%<(SLibCGCallSubFcn("k1scvijul4", ["obj_p"], 0, 92, 16))> || (!%<(SLibCGCallSubFcn("irhvzala2k", ["obj_p"], 0, 92, 17))>)) {
                    done = true;
                }
                et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj_p->StreamImpl"], 0, 92, 18))>;
                et += obj_p->PartialPacketCount;
                completed = (et > 0.0);
            }
        }
        tokenFound = false;
        obj_p = &obj->AsyncIOChannel->InputStream;
        et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj_p->StreamImpl"], 0, 92, 19))>;
        et += obj_p->PartialPacketCount;
        if (et == 0.0) {
            data->size[0] = 1;
            data->size[1] = 0;
        } else {
            obj_p = &obj->AsyncIOChannel->InputStream;
            et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj_p->StreamImpl"], 0, 92, 20))>;
            et += obj_p->PartialPacketCount;
            %<(SLibCGCallSubFcn("d1cnfcxsqs", ["&obj->AsyncIOChannel->InputStream", "et", "searchData", "&timeoutInSeconds", "status_data", "status_size"], 0, 92, 21))>;
            %<(SLibCGCallSubFcn("g1pihrrgkp", ["&obj->UnreadDataBuffer", "searchData"], 0, 92, 22))>;
            et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->UnreadDataBuffer.InputStream.StreamImpl"], 0, 92, 23))>;
            et += obj->UnreadDataBuffer.InputStream.PartialPacketCount;
            et += obj->UnreadDataBuffer.PartialPacketCount;
            et /= obj->UnreadDataBuffer.BytesPerElement;
            if (et != 0.0) {
                et = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->UnreadDataBuffer.InputStream.StreamImpl"], 0, 92, 24))>;
                et += obj->UnreadDataBuffer.InputStream.PartialPacketCount;
                et += obj->UnreadDataBuffer.PartialPacketCount;
                et /= obj->UnreadDataBuffer.BytesPerElement;
                if (et == 0.0) {
                    searchData->size[0] = 0;
                    searchData->size[1] = 0;
                } else {
                    %<(SLibCGCallSubFcn("idaplsfg2k", ["&obj->UnreadDataBuffer", "et * obj->UnreadDataBuffer.BytesPerElement", "searchData"], 0, 92, 25))>;
                }
            } else {
                searchData->size[0] = 0;
                searchData->size[1] = 0;
            }
            tmp = searchDataChar->size[0] * searchDataChar->size[1];
            searchDataChar->size[0] = searchData->size[0];
            searchDataChar->size[1] = searchData->size[1];
            %<(SLibCGCallSubFcn("kt1e3yths5", ["searchDataChar", "tmp"], 0, 92, 34))>;
            match_idx = searchData->size[0] * searchData->size[1];
            for (text_len = 0; text_len < match_idx; text_len++) {
                searchDataChar->data[text_len] = (int8_T)searchData->data[text_len];
            }
            if ((searchDataChar->size[0] == 0) || (searchDataChar->size[1] == 0)) {
                matches->size[0] = 1;
                matches->size[1] = 0;
            } else {
                text_len = searchDataChar->size[0] * searchDataChar->size[1];
                tmp = matches->size[0] * matches->size[1];
                matches->size[0] = 1;
                matches->size[1] = text_len;
                %<(SLibCGCallSubFcn("nvhcqcdzap", ["matches", "tmp"], 0, 92, 36))>;
                match_idx = 0;
                for (b_idx_0 = 0; b_idx_0 < text_len; b_idx_0++) {
                    if (searchDataChar->data[b_idx_0] == 'S') {
                        matches->data[match_idx] = b_idx_0 + 1;
                        match_idx++;
                    }
                }
                tmp = match_out->size[0] * match_out->size[1];
                match_out->size[0] = 1;
                match_out->size[1] = match_idx;
                %<(SLibCGCallSubFcn("nvhcqcdzap", ["match_out", "tmp"], 0, 92, 37))>;
                if (match_idx - 1 >= 0) {
                    memcpy(&match_out->data[0], &matches->data[0], (uint32_T)match_idx * sizeof(int32_T));
                }
                tmp = matches->size[0] * matches->size[1];
                matches->size[0] = 1;
                matches->size[1] = match_out->size[1];
                %<(SLibCGCallSubFcn("nvhcqcdzap", ["matches", "tmp"], 0, 92, 39))>;
                match_idx = match_out->size[1];
                if (match_idx - 1 >= 0) {
                    memcpy(&matches->data[0], &match_out->data[0], (uint32_T)match_idx * sizeof(int32_T));
                }
            }
            if (matches->size[1] != 0) {
                tokenFound = true;
                match_idx = (int32_T)(((real_T)matches->data[0] + 1.0) - 1.0);
                tmp = data->size[0] * data->size[1];
                data->size[0] = 1;
                data->size[1] = match_idx;
                %<(SLibCGCallSubFcn("fptaaqsn5k", ["data", "tmp"], 0, 92, 38))>;
                if (match_idx - 1 >= 0) {
                    memcpy(&data->data[0], &searchData->data[0], (uint32_T)match_idx * sizeof(uint8_T));
                }
                if ((searchData->size[0] == 0) || (searchData->size[1] == 0)) {
                    b_idx_0 = 0;
                } else {
                    text_len = searchData->size[0];
                    b_idx_0 = searchData->size[1];
                    b_idx_0 = muIntScalarMax_sint32(text_len, b_idx_0);
                }
                if ((int32_T)(((real_T)matches->data[0] + 1.0) - 1.0) < b_idx_0) {
                    et = searchData->size[0] * searchData->size[1];
                    if ((((real_T)matches->data[0] + 1.0) - 1.0) + 1.0 > et) {
                        b_idx_0 = 0;
                        text_len = 0;
                    } else {
                        b_idx_0 = (int32_T)(((real_T)matches->data[0] + 1.0) - 1.0);
                        text_len = (int32_T)et;
                    }
                    tmp = searchData_p->size[0] * searchData_p->size[1];
                    searchData_p->size[0] = 1;
                    searchData_p->size[1] = text_len - b_idx_0;
                    %<(SLibCGCallSubFcn("fptaaqsn5k", ["searchData_p", "tmp"], 0, 92, 40))>;
                    match_idx = text_len - b_idx_0;
                    for (text_len = 0; text_len < match_idx; text_len++) {
                        searchData_p->data[text_len] = searchData->data[b_idx_0 + text_len];
                    }
                    %<(SLibCGCallSubFcn("g1pihrrgkpd", ["&obj->UnreadDataBuffer", "searchData_p"], 0, 92, 26))>;
                }
            } else {
                %<(SLibCGCallSubFcn("g1pihrrgkp", ["&obj->UnreadDataBuffer", "searchData"], 0, 92, 27))>;
                data->size[0] = 1;
                data->size[1] = 0;
            }
        }
        %<(SLibCGCallSubFcn("btyi2yuuqqr", ["a__3", "startTic_tv_nsec"], 0, 92, 28))>;
    }
}
%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&searchData_p"], 0, 92, 50))>;
%<(SLibCGCallSubFcn("ptt1gjr52i", ["&matches"], 0, 92, 49))>;
%<(SLibCGCallSubFcn("ptt1gjr52i", ["&match_out"], 0, 92, 48))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&searchDataChar"], 0, 92, 47))>;
%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&searchData"], 0, 92, 46))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void grofjyw12k(\
%assign comma = ""
%<comma>habembxjyg *obj\
%assign comma = ", "
%<comma>ftbvbe5nvy *data\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 92, fcnProtoType)>
%return fcnBuff
%endfunction

%function mthrheuinf_Fcn93(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
csy5egbntl *emxArray;
int32_T i;
*pEmxArray = (csy5egbntl *)malloc(sizeof(csy5egbntl));
emxArray = *pEmxArray;
emxArray->data = (uint32_T *)NULL;
emxArray->numDimensions = numDimensions;
emxArray->size = (int32_T *)malloc(sizeof(int32_T) * (uint32_T)numDimensions);
emxArray->allocatedSize = 0;
emxArray->canFreeData = true;
for (i = 0; i < numDimensions; i++) {
    emxArray->size[i] = 0;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void mthrheuinf(\
%assign comma = ""
%<comma>csy5egbntl **pEmxArray\
%assign comma = ", "
%<comma>int32_T numDimensions\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 93, fcnProtoType)>
%return fcnBuff
%endfunction

%function kaxjaudcrw_Fcn94(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
int32_T newNumel;
void *newData;
if (oldNumel < 0) {
    oldNumel = 0;
}
newNumel = 1;
for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel *= emxArray->size[i];
}
if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
        i = 16;
    }
    while (i < newNumel) {
        if (i > 1073741823) {
            i = MAX_int32_T;
        } else {
            i <<= 1;
        }
    }
    newData = malloc((uint32_T)i * sizeof(uint32_T));
    if (emxArray->data != NULL) {
        memcpy(newData, emxArray->data, sizeof(uint32_T) * (uint32_T)oldNumel);
        if (emxArray->canFreeData) {
            free(emxArray->data);
        }
    }
    emxArray->data = (uint32_T *)newData;
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void kaxjaudcrw(\
%assign comma = ""
%<comma>csy5egbntl *emxArray\
%assign comma = ", "
%<comma>int32_T oldNumel\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 94, fcnProtoType)>
%return fcnBuff
%endfunction

%function bhdpi5r1ky_Fcn95(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
if (*pEmxArray != (csy5egbntl *)NULL) {
    if (((*pEmxArray)->data != (uint32_T *)NULL) && (*pEmxArray)->canFreeData) {
        free((*pEmxArray)->data);
    }
    free((*pEmxArray)->size);
    free(*pEmxArray);
    *pEmxArray = (csy5egbntl *)NULL;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void bhdpi5r1ky(\
%assign comma = ""
%<comma>csy5egbntl **pEmxArray\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 95, fcnProtoType)>
%return fcnBuff
%endfunction

%function no0t3uuspe_Fcn96(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
afxtk4erg3 *obj_e;
csy5egbntl *out;
ftbvbe5nvy *dataRead;
ftbvbe5nvy *dataRead_e;
ftbvbe5nvy *dataRead_p;
ftbvbe5nvy *excessData;
habembxjyg *obj;
he1ich2doy *match_out;
he1ich2doy *matches;
hgyzgm1py1 *dataToPeekFrom;
i0lstc3zfv *obj_p;
mwbcmoqwkf *packets;
real_T b_countRead;
real_T count;
real_T count_p;
uint64_T qY;
uint64_T totalBytesWritten;
int32_T status_size[2];
int32_T exitg2;
int32_T loop_ub;
int32_T match_idx;
int32_T ns;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
char_T status_data[9];
boolean_T exitg1;
boolean_T exitg3;
boolean_T guard1;
boolean_T guard11;
boolean_T hasSyncError;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,96,31,0)
%<SLibCG_AccessArg(0 ,96, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,96,22,0)
%<SLibCG_AccessArg(0 ,96, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,96,3,0)
%<SLibCG_AccessArg(0 ,96, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,96,2,0)
%<SLibCG_AccessArg(0 ,96, 0)>
%endif

loop_ub = varargout_1->size[0] * varargout_1->size[1];
varargout_1->size[0] = 1;
varargout_1->size[1] = 1;
%<(SLibCGCallSubFcn("hndnmfdyav", ["varargout_1", "loop_ub"], 0, 96, 22))>;
varargout_1->data[0] = 0.0;
*status = false;
%<(SLibCGCallSubFcn("i2ato1xcxy", [], 0, 96, 0))>;
%<(SLibCGCallSubFcn("c2wgnvw4uy", ["&dataToPeekFrom", "2"], 0, 96, 34))>;
%<(SLibCGCallSubFcn("mthrheuinf", ["&out", "2"], 0, 96, 35))>;
%<(SLibCGCallSubFcn("iv4amyl51q", ["&match_out", "2"], 0, 96, 36))>;
%<(SLibCGCallSubFcn("iv4amyl51q", ["&matches", "2"], 0, 96, 37))>;
%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&dataRead", "2"], 0, 96, 38))>;
%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&excessData", "2"], 0, 96, 39))>;
%<(SLibCGCallSubFcn("ol04rdb3hp", ["&packets", "2"], 0, 96, 40))>;
%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&dataRead_p", "2"], 0, 96, 41))>;
%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&dataRead_e", "2"], 0, 96, 42))>;
exitg1 = false;
while ((!exitg1) && (%<(SLibCGCallSubFcn("btyi2yuuqq", [], 0, 96, 1))> < %<(SLibCGCallSubFcn("lcng5t0i0z", ["serialObject"], 0, 96, 2))>)) {
    %<(SLibCGCallSubFcn("o4wczq2e3h", ["serialObject"], 0, 96, 3))>;
    obj = serialObject->TransportChannel;
    varargout_1->size[0] = 0;
    varargout_1->size[1] = 0;
    obj_p = &obj->AsyncIOChannel->InputStream;
    count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj_p->StreamImpl"], 0, 96, 4))>;
    count += obj_p->PartialPacketCount;
    obj_p = &obj->AsyncIOChannel->InputStream;
    loop_ub = obj_p->ExampleData->size[0] * obj_p->ExampleData->size[1];
    obj_p->ExampleData->size[0] = 1;
    obj_p->ExampleData->size[1] = 1;
    %<(SLibCGCallSubFcn("fptaaqsn5k", ["obj_p->ExampleData", "loop_ub"], 0, 96, 23))>;
    obj_p->ExampleData->data[0] = 0U;
    match_idx = 0;
    %<(SLibCGCallSubFcn("jvsizsb3rg", ["obj_p", "count", "dataRead", "&b_countRead"], 0, 96, 5))>;
    if (b_countRead == count) {
        %<(SLibCGCallSubFcn("m0m3nyxjg4a", ["dataRead", "(real_T)dataRead->size[1]", "excessData"], 0, 96, 6))>;
    } else {
        guard1 = false;
        do {
            exitg2 = 0;
            if (b_countRead < count) {
                count_p = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj_p->StreamImpl"], 0, 96, 7))>;
                guard11 = false;
                if (count_p == 0.0) {
                    %<(SLibCGCallSubFcn("a5gqemnbabo", ["obj_p", "status_data", "status_size"], 0, 96, 8))>;
                    if (!%<(SLibCGCallSubFcn("l1feuv03fpl", ["status_data", "status_size"], 0, 96, 9))>) {
                        match_idx = status_size[1];
                        if (%<(SLibCGCallSubFcn("l1feuv03fple", ["status_data", "status_size"], 0, 96, 10))>) {
                            excessData->size[0] = 1;
                            excessData->size[1] = 0;
                        } else {
                            if (%<(SLibCGCallSubFcn("l1feuv03fpleo", ["status_data", "status_size"], 0, 96, 11))>) {
                                match_idx = 0;
                            }
                            guard1 = true;
                        }
                        exitg2 = 1;
                    } else {
                        guard11 = true;
                    }
                } else {
                    guard11 = true;
                }
                if (guard11) {
                    %<(SLibCGCallSubFcn("fln1whbkdj", ["obj_p", "count - b_countRead", "packets", "&count_p"], 0, 96, 12))>;
                    success = packets->size[1];
                    for (ns = 0; ns < success; ns++) {
                        loop_ub = dataRead_e->size[0] * dataRead_e->size[1];
                        dataRead_e->size[0] = dataRead->size[0];
                        dataRead_e->size[1] = dataRead->size[1];
                        %<(SLibCGCallSubFcn("fptaaqsn5k", ["dataRead_e", "loop_ub"], 0, 96, 27))>;
                        loop_ub = dataRead->size[0] * dataRead->size[1] - 1;
                        if (loop_ub >= 0) {
                            memcpy(&dataRead_e->data[0], &dataRead->data[0], (uint32_T)(loop_ub + 1) * sizeof(uint8_T));
                        }
                        %<(SLibCGCallSubFcn("gs0i0ykog4", ["dataRead_e", "packets->data[ns].f1", "dataRead"], 0, 96, 13))>;
                    }
                    b_countRead += count_p;
                    guard1 = false;
                }
            } else {
                guard1 = true;
                exitg2 = 1;
            }
        } while (exitg2 == 0);
        if (guard1) {
            if (b_countRead > count) {
                %<(SLibCGCallSubFcn("m0m3nyxjg4", ["dataRead", "count + 1.0", "b_countRead", "excessData"], 0, 96, 14))>;
                loop_ub = obj_p->PartialPacket->size[0] * obj_p->PartialPacket->size[1];
                obj_p->PartialPacket->size[0] = excessData->size[0];
                obj_p->PartialPacket->size[1] = excessData->size[1];
                %<(SLibCGCallSubFcn("fptaaqsn5k", ["obj_p->PartialPacket", "loop_ub"], 0, 96, 24))>;
                success = excessData->size[0] * excessData->size[1];
                for (ns = 0; ns < success; ns++) {
                    obj_p->PartialPacket->data[ns] = excessData->data[ns];
                }
                obj_p->PartialPacketStart = 1.0;
                obj_p->PartialPacketCount = excessData->size[1];
                loop_ub = dataRead_p->size[0] * dataRead_p->size[1];
                dataRead_p->size[0] = dataRead->size[0];
                dataRead_p->size[1] = dataRead->size[1];
                %<(SLibCGCallSubFcn("fptaaqsn5k", ["dataRead_p", "loop_ub"], 0, 96, 28))>;
                loop_ub = dataRead->size[0] * dataRead->size[1] - 1;
                if (loop_ub >= 0) {
                    memcpy(&dataRead_p->data[0], &dataRead->data[0], (uint32_T)(loop_ub + 1) * sizeof(uint8_T));
                }
                %<(SLibCGCallSubFcn("m0m3nyxjg4a", ["dataRead_p", "count", "dataRead"], 0, 96, 15))>;
            }
            if (match_idx != 0) {
                loop_ub = obj_p->PartialPacket->size[0] * obj_p->PartialPacket->size[1];
                obj_p->PartialPacket->size[0] = dataRead->size[0];
                obj_p->PartialPacket->size[1] = dataRead->size[1];
                %<(SLibCGCallSubFcn("fptaaqsn5k", ["obj_p->PartialPacket", "loop_ub"], 0, 96, 25))>;
                success = dataRead->size[0] * dataRead->size[1];
                for (ns = 0; ns < success; ns++) {
                    obj_p->PartialPacket->data[ns] = dataRead->data[ns];
                }
                obj_p->PartialPacketStart = 1.0;
                obj_p->PartialPacketCount = dataRead->size[1];
                excessData->size[0] = 1;
                excessData->size[1] = 0;
            } else {
                loop_ub = excessData->size[0] * excessData->size[1];
                excessData->size[0] = dataRead->size[0];
                excessData->size[1] = dataRead->size[1];
                %<(SLibCGCallSubFcn("fptaaqsn5k", ["excessData", "loop_ub"], 0, 96, 26))>;
                success = dataRead->size[0] * dataRead->size[1];
                if (success - 1 >= 0) {
                    memcpy(&excessData->data[0], &dataRead->data[0], (uint32_T)success * sizeof(uint8_T));
                }
            }
        }
    }
    if ((excessData->size[0] != 0) && (excessData->size[1] != 0)) {
        %<(SLibCGCallSubFcn("g1pihrrgkp", ["&obj->UnreadDataBuffer", "excessData"], 0, 96, 16))>;
    }
    count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->UnreadDataBuffer.InputStream.StreamImpl"], 0, 96, 17))>;
    count += obj->UnreadDataBuffer.InputStream.PartialPacketCount;
    count += obj->UnreadDataBuffer.PartialPacketCount;
    count /= obj->UnreadDataBuffer.BytesPerElement;
    if (count != 0.0) {
        count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->UnreadDataBuffer.InputStream.StreamImpl"], 0, 96, 18))>;
        count += obj->UnreadDataBuffer.InputStream.PartialPacketCount;
        count += obj->UnreadDataBuffer.PartialPacketCount;
        count /= obj->UnreadDataBuffer.BytesPerElement;
        if (count == 0.0) {
            excessData->size[0] = 0;
            excessData->size[1] = 0;
        } else {
            %<(SLibCGCallSubFcn("idaplsfg2k", ["&obj->UnreadDataBuffer", "count * obj->UnreadDataBuffer.BytesPerElement", "excessData"], 0, 96, 19))>;
        }
    } else {
        excessData->size[0] = 0;
        excessData->size[1] = 0;
    }
    if ((excessData->size[0] == 0) || (excessData->size[1] == 0)) {
        ns = 0;
    } else {
        ns = excessData->size[0];
        success = excessData->size[1];
        ns = muIntScalarMax_sint32(ns, success);
    }
    obj_e = obj->AsyncIOChannel;
    chImpl = obj_e->ChannelImpl;
    success = coderChannelExecute(chImpl, "GetTotalBytesWrittenStatus", 0);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
    obj_e = obj->AsyncIOChannel;
    totalBytesWritten = obj_e->CustomProps.TotalBytesWritten;
    chImpl = obj_e->ChannelImpl;
    success = coderChannelGetPropertyValue(chImpl, "TotalBytesWritten", "uint64", 1, &totalBytesWritten);
    if (success == 0) {
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
    if (ns <= 0) {
        totalBytesWritten = 0ULL;
    } else {
        totalBytesWritten = (uint64_T)ns - totalBytesWritten;
        if (totalBytesWritten > (uint64_T)ns) {
            totalBytesWritten = 0ULL;
        }
    }
    qY = totalBytesWritten + 1ULL;
    if (totalBytesWritten + 1ULL < totalBytesWritten) {
        qY = MAX_uint64_T;
    }
    hasSyncError = false;
    if (qY < 4503599627370496ULL) {
        hasSyncError = ((real_T)qY < ns);
    }
    if (hasSyncError) {
        if (qY > (uint64_T)ns) {
            success = 0;
            ns = 0;
        } else {
            success = (int32_T)qY - 1;
        }
        match_idx = ns - success;
        loop_ub = dataToPeekFrom->size[0] * dataToPeekFrom->size[1];
        dataToPeekFrom->size[0] = 1;
        dataToPeekFrom->size[1] = match_idx;
        %<(SLibCGCallSubFcn("kt1e3yths5", ["dataToPeekFrom", "loop_ub"], 0, 96, 29))>;
        for (ns = 0; ns < match_idx; ns++) {
            dataToPeekFrom->data[ns] = (int8_T)excessData->data[success + ns];
        }
        if (dataToPeekFrom->size[1] == 0) {
            out->size[0] = 1;
            out->size[1] = 0;
        } else {
            success = dataToPeekFrom->size[1];
            loop_ub = matches->size[0] * matches->size[1];
            matches->size[0] = 1;
            matches->size[1] = dataToPeekFrom->size[1];
            %<(SLibCGCallSubFcn("nvhcqcdzap", ["matches", "loop_ub"], 0, 96, 30))>;
            match_idx = 0;
            for (ns = 0; ns < success; ns++) {
                if (dataToPeekFrom->data[ns] == 'E') {
                    matches->data[match_idx] = ns + 1;
                    match_idx++;
                }
            }
            loop_ub = match_out->size[0] * match_out->size[1];
            match_out->size[0] = 1;
            match_out->size[1] = match_idx;
            %<(SLibCGCallSubFcn("nvhcqcdzap", ["match_out", "loop_ub"], 0, 96, 32))>;
            if (match_idx - 1 >= 0) {
                memcpy(&match_out->data[0], &matches->data[0], (uint32_T)match_idx * sizeof(int32_T));
            }
            loop_ub = out->size[0] * out->size[1];
            out->size[0] = 1;
            out->size[1] = match_out->size[1];
            %<(SLibCGCallSubFcn("kaxjaudcrw", ["out", "loop_ub"], 0, 96, 33))>;
            success = match_out->size[1];
            for (ns = 0; ns < success; ns++) {
                out->data[ns] = (uint32_T)match_out->data[ns];
            }
        }
        loop_ub = varargout_1->size[0] * varargout_1->size[1];
        varargout_1->size[0] = 1;
        varargout_1->size[1] = out->size[1];
        %<(SLibCGCallSubFcn("hndnmfdyav", ["varargout_1", "loop_ub"], 0, 96, 31))>;
        success = out->size[1];
        for (ns = 0; ns < success; ns++) {
            varargout_1->data[ns] = out->data[ns];
        }
    }
    if ((excessData->size[0] != 0) && (excessData->size[1] != 0)) {
        %<(SLibCGCallSubFcn("g1pihrrgkp", ["&obj->UnreadDataBuffer", "excessData"], 0, 96, 20))>;
    }
    if ((varargout_1->size[0] != 0) && (varargout_1->size[1] != 0)) {
        ns = varargout_1->size[1] - 1;
        hasSyncError = false;
        success = 0;
        exitg3 = false;
        while ((!exitg3) && (success <= ns)) {
            if ((int32_T)varargout_1->data[success] == 17) {
                hasSyncError = true;
                exitg3 = true;
            } else {
                success++;
            }
        }
        if (hasSyncError) {
            *status = true;
            exitg1 = true;
        } else {
            %<(SLibCGCallSubFcn("jrnq5jhfee", ["0.001"], 0, 96, 21))>;
        }
    } else {
        %<(SLibCGCallSubFcn("jrnq5jhfee", ["0.001"], 0, 96, 21))>;
    }
}
%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&dataRead_e"], 0, 96, 51))>;
%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&dataRead_p"], 0, 96, 50))>;
%<(SLibCGCallSubFcn("o55ouaau02", ["&packets"], 0, 96, 49))>;
%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&excessData"], 0, 96, 48))>;
%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&dataRead"], 0, 96, 47))>;
%<(SLibCGCallSubFcn("ptt1gjr52i", ["&matches"], 0, 96, 46))>;
%<(SLibCGCallSubFcn("ptt1gjr52i", ["&match_out"], 0, 96, 45))>;
%<(SLibCGCallSubFcn("bhdpi5r1ky", ["&out"], 0, 96, 44))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&dataToPeekFrom"], 0, 96, 43))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void no0t3uuspe(\
%assign comma = ""
%<comma>fops2f5bc4 *serialObject\
%assign comma = ", "
%<comma>boolean_T *status\
%assign comma = ", "
%<comma>i3054vb1je *varargout_1\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 96, fcnProtoType)>
%return fcnBuff
%endfunction

%function mtemkfzopj_Fcn97(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
dyih3sogw2 *emxArray;
int32_T i;
*pEmxArray = (dyih3sogw2 *)malloc(sizeof(dyih3sogw2));
emxArray = *pEmxArray;
emxArray->data = (real32_T *)NULL;
emxArray->numDimensions = numDimensions;
emxArray->size = (int32_T *)malloc(sizeof(int32_T) * (uint32_T)numDimensions);
emxArray->allocatedSize = 0;
emxArray->canFreeData = true;
for (i = 0; i < numDimensions; i++) {
    emxArray->size[i] = 0;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void mtemkfzopj(\
%assign comma = ""
%<comma>dyih3sogw2 **pEmxArray\
%assign comma = ", "
%<comma>int32_T numDimensions\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 97, fcnProtoType)>
%return fcnBuff
%endfunction

%function ij0lyu32uz_Fcn98(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
real_T count;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,98,5,0)
%<SLibCG_AccessArg(0 ,98, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,98,4,0)
%<SLibCG_AccessArg(0 ,98, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,98,3,0)
%<SLibCG_AccessArg(0 ,98, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,98,2,0)
%<SLibCG_AccessArg(0 ,98, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,98,1,0)
%<SLibCG_AccessArg(0 ,98, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,98,1,1)
%<SLibCG_AccessArg(0 ,98, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,98,1,2)
%<SLibCG_AccessArg(0 ,98, 2)>
%endif

%if SLibCG_FcnCallArgAccessed(0,98,0,0)
%<SLibCG_AccessArg(0 ,98, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,98,0,1)
%<SLibCG_AccessArg(0 ,98, 0)>
%endif
%if SLibCG_FcnCallArgAccessed(0,98,0,2)
%<SLibCG_AccessArg(0 ,98, 2)>
%endif

count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->UnreadDataBuffer.InputStream.StreamImpl"], 0, 98, 4))>;
if (numToRead > ((obj->UnreadDataBuffer.InputStream.PartialPacketCount + count) + obj->UnreadDataBuffer.PartialPacketCount) / obj->UnreadDataBuffer.BytesPerElement) {
    count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->UnreadDataBuffer.InputStream.StreamImpl"], 0, 98, 2))>;
    if (((obj->UnreadDataBuffer.InputStream.PartialPacketCount + count) + obj->UnreadDataBuffer.PartialPacketCount) / obj->UnreadDataBuffer.BytesPerElement != 0.0) {
        count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->UnreadDataBuffer.InputStream.StreamImpl"], 0, 98, 3))>;
        count = ((obj->UnreadDataBuffer.InputStream.PartialPacketCount + count) + obj->UnreadDataBuffer.PartialPacketCount) / obj->UnreadDataBuffer.BytesPerElement;
        if (count == 0.0) {
            data->size[0] = 0;
            data->size[1] = 0;
        } else {
            %<(SLibCGCallSubFcn("idaplsfg2k", ["&obj->UnreadDataBuffer", "count * obj->UnreadDataBuffer.BytesPerElement", "data"], 0, 98, 1))>;
        }
    } else {
        data->size[0] = 0;
        data->size[1] = 0;
    }
} else {
    count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->UnreadDataBuffer.InputStream.StreamImpl"], 0, 98, 5))>;
    count = muDoubleScalarMin(numToRead, ((obj->UnreadDataBuffer.InputStream.PartialPacketCount + count) + obj->UnreadDataBuffer.PartialPacketCount) / obj->UnreadDataBuffer.BytesPerElement);
    if (count == 0.0) {
        data->size[0] = 0;
        data->size[1] = 0;
    } else {
        %<(SLibCGCallSubFcn("idaplsfg2k", ["&obj->UnreadDataBuffer", "count * obj->UnreadDataBuffer.BytesPerElement", "data"], 0, 98, 0))>;
    }
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void ij0lyu32uz(\
%assign comma = ""
%<comma>habembxjyg *obj\
%assign comma = ", "
%<comma>real_T numToRead\
%assign comma = ", "
%<comma>ftbvbe5nvy *data\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 98, fcnProtoType)>
%return fcnBuff
%endfunction

%function bo1xlfsvz3_Fcn99(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
ftbvbe5nvy *b_rawData;
ftbvbe5nvy *rawData;
ftbvbe5nvy *tempDataArray;
ftbvbe5nvy *x;
habembxjyg *obj;
habembxjyg *varargin_1_p;
i0lstc3zfv *obj_p;
real_T count;
real_T numBytesToRead;
real_T startTic_tv_nsec;
real_T startTic_tv_sec;
int32_T b_status_size[2];
int32_T i;
int32_T loop_ub;
char_T b_status_data[9];
boolean_T exitg1;
boolean_T hasEnoughData;
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,99,21,0)
%<SLibCG_AccessArg(0 ,99, 1)>
%endif

%if SLibCG_FcnCallArgAccessed(0,99,1,0)
%<SLibCG_AccessArg(0 ,99, 0)>
%endif

%<(SLibCGCallSubFcn("o4wczq2e3h", ["varargin_1"], 0, 99, 1))>;
varargin_1_p = varargin_1->TransportChannel;
obj = varargin_1_p;
%<(SLibCGCallSubFcn("mw2mi4zvh2", ["&rawData", "2"], 0, 99, 22))>;
rawData->size[0] = 0;
rawData->size[1] = 0;
count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["varargin_1_p->UnreadDataBuffer.InputStream.StreamImpl"], 0, 99, 14))>;
count += varargin_1_p->UnreadDataBuffer.InputStream.PartialPacketCount;
count += varargin_1_p->UnreadDataBuffer.PartialPacketCount;
count /= varargin_1_p->UnreadDataBuffer.BytesPerElement;
if (count >= 17.0) {
    %<(SLibCGCallSubFcn("ij0lyu32uz", ["varargin_1_p", "17.0", "rawData"], 0, 99, 9))>;
} else {
    count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["varargin_1_p->UnreadDataBuffer.InputStream.StreamImpl"], 0, 99, 15))>;
    count += varargin_1_p->UnreadDataBuffer.InputStream.PartialPacketCount;
    count += varargin_1_p->UnreadDataBuffer.PartialPacketCount;
    count /= varargin_1_p->UnreadDataBuffer.BytesPerElement;
    numBytesToRead = 17.0 - count;
    hasEnoughData = false;
    %<(SLibCGCallSubFcn("i2ato1xcxyf", ["&startTic_tv_sec", "&startTic_tv_nsec"], 0, 99, 18))>;
    exitg1 = false;
    while ((!exitg1) && (%<(SLibCGCallSubFcn("btyi2yuuqqr", ["startTic_tv_sec", "startTic_tv_nsec"], 0, 99, 0))> < obj->AsyncIOChannel->InputStream.Timeout)) {
        obj_p = &obj->AsyncIOChannel->InputStream;
        count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj_p->StreamImpl"], 0, 99, 10))>;
        count += obj_p->PartialPacketCount;
        if (count >= numBytesToRead) {
            hasEnoughData = true;
            exitg1 = true;
        } else {
            %<(SLibCGCallSubFcn("jrnq5jhfee", ["0.01"], 0, 99, 6))>;
        }
    }
    if (hasEnoughData) {
        obj_p = &obj->AsyncIOChannel->InputStream;
        count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj_p->StreamImpl"], 0, 99, 11))>;
        count += obj_p->PartialPacketCount;
        %<(SLibCGCallSubFcn("d1cnfcxsqs", ["&obj->AsyncIOChannel->InputStream", "count", "rawData", "&numBytesToRead", "b_status_data", "b_status_size"], 0, 99, 5))>;
        %<(SLibCGCallSubFcn("g1pihrrgkp", ["&obj->UnreadDataBuffer", "rawData"], 0, 99, 4))>;
        %<(SLibCGCallSubFcn("ij0lyu32uz", ["obj", "17.0", "rawData"], 0, 99, 8))>;
    } else if (obj->AllowPartialReads) {
        obj_p = &obj->AsyncIOChannel->InputStream;
        count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj_p->StreamImpl"], 0, 99, 12))>;
        count += obj_p->PartialPacketCount;
        if (count > 0.0) {
            obj_p = &obj->AsyncIOChannel->InputStream;
            count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj_p->StreamImpl"], 0, 99, 13))>;
            count += obj_p->PartialPacketCount;
            %<(SLibCGCallSubFcn("mw2mi4zvh2", ["&b_rawData", "2"], 0, 99, 23))>;
            %<(SLibCGCallSubFcn("d1cnfcxsqs", ["&obj->AsyncIOChannel->InputStream", "count", "b_rawData", "&numBytesToRead", "b_status_data", "b_status_size"], 0, 99, 3))>;
            %<(SLibCGCallSubFcn("g1pihrrgkp", ["&obj->UnreadDataBuffer", "b_rawData"], 0, 99, 2))>;
            %<(SLibCGCallSubFcn("lv0yfzd1c2", ["&b_rawData"], 0, 99, 27))>;
        }
        count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->UnreadDataBuffer.InputStream.StreamImpl"], 0, 99, 16))>;
        count += obj->UnreadDataBuffer.InputStream.PartialPacketCount;
        count += obj->UnreadDataBuffer.PartialPacketCount;
        count /= obj->UnreadDataBuffer.BytesPerElement;
        if (count > 0.0) {
            count = %<(SLibCGCallSubFcn("dwh2lws3bw", ["obj->UnreadDataBuffer.InputStream.StreamImpl"], 0, 99, 17))>;
            count += obj->UnreadDataBuffer.InputStream.PartialPacketCount;
            count += obj->UnreadDataBuffer.PartialPacketCount;
            count /= obj->UnreadDataBuffer.BytesPerElement;
            %<(SLibCGCallSubFcn("ij0lyu32uz", ["obj", "muDoubleScalarMin(17.0, count)", "rawData"], 0, 99, 7))>;
        }
    }
}
if ((rawData->size[0] == 0) || (rawData->size[1] == 0)) {
    data->size[0] = 0;
    data->size[1] = 0;
} else {
    %<(SLibCGCallSubFcn("mw2mi4zvh2", ["&x", "2"], 0, 99, 25))>;
    i = x->size[0] * x->size[1];
    x->size[0] = 1;
    x->size[1] = rawData->size[1];
    %<(SLibCGCallSubFcn("fptaaqsn5k", ["x", "i"], 0, 99, 19))>;
    loop_ub = rawData->size[1];
    for (i = 0; i < loop_ub; i++) {
        x->data[i] = rawData->data[rawData->size[0] * i];
    }
    %<(SLibCGCallSubFcn("mw2mi4zvh2", ["&tempDataArray", "2"], 0, 99, 24))>;
    i = tempDataArray->size[0] * tempDataArray->size[1];
    tempDataArray->size[0] = 1;
    tempDataArray->size[1] = rawData->size[1];
    %<(SLibCGCallSubFcn("fptaaqsn5k", ["tempDataArray", "i"], 0, 99, 20))>;
    memcpy((void *)&tempDataArray->data[0], (void *)&x->data[0], (uint32_T)((size_t)rawData->size[1] * sizeof(uint8_T)));
    %<(SLibCGCallSubFcn("lv0yfzd1c2", ["&x"], 0, 99, 29))>;
    i = data->size[0] * data->size[1];
    data->size[0] = 1;
    data->size[1] = tempDataArray->size[1];
    %<(SLibCGCallSubFcn("fptaaqsn5k", ["data", "i"], 0, 99, 21))>;
    loop_ub = tempDataArray->size[1];
    memcpy(&data->data[0], &tempDataArray->data[0], (uint32_T)loop_ub * sizeof(uint8_T));
    %<(SLibCGCallSubFcn("lv0yfzd1c2", ["&tempDataArray"], 0, 99, 28))>;
}
%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&rawData"], 0, 99, 26))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void bo1xlfsvz3(\
%assign comma = ""
%<comma>fops2f5bc4 *varargin_1\
%assign comma = ", "
%<comma>ftbvbe5nvy *data\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 99, fcnProtoType)>
%return fcnBuff
%endfunction

%function kr15fhvgo4_Fcn100(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T i;
int32_T newNumel;
void *newData;
if (oldNumel < 0) {
    oldNumel = 0;
}
newNumel = 1;
for (i = 0; i < emxArray->numDimensions; i++) {
    newNumel *= emxArray->size[i];
}
if (newNumel > emxArray->allocatedSize) {
    i = emxArray->allocatedSize;
    if (i < 16) {
        i = 16;
    }
    while (i < newNumel) {
        if (i > 1073741823) {
            i = MAX_int32_T;
        } else {
            i <<= 1;
        }
    }
    newData = malloc((uint32_T)i * sizeof(real32_T));
    if (emxArray->data != NULL) {
        memcpy(newData, emxArray->data, sizeof(real32_T) * (uint32_T)oldNumel);
        if (emxArray->canFreeData) {
            free(emxArray->data);
        }
    }
    emxArray->data = (real32_T *)newData;
    emxArray->allocatedSize = i;
    emxArray->canFreeData = true;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void kr15fhvgo4(\
%assign comma = ""
%<comma>dyih3sogw2 *emxArray\
%assign comma = ", "
%<comma>int32_T oldNumel\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 100, fcnProtoType)>
%return fcnBuff
%endfunction

%function atxdmk14rg_Fcn101(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
if (*pEmxArray != (dyih3sogw2 *)NULL) {
    if (((*pEmxArray)->data != (real32_T *)NULL) && (*pEmxArray)->canFreeData) {
        free((*pEmxArray)->data);
    }
    free((*pEmxArray)->size);
    free(*pEmxArray);
    *pEmxArray = (dyih3sogw2 *)NULL;
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void atxdmk14rg(\
%assign comma = ""
%<comma>dyih3sogw2 **pEmxArray\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 101, fcnProtoType)>
%return fcnBuff
%endfunction

%function l0bscn2j24kn_Fcn102(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T hasSyncError;
boolean_T result;
success = coderChannelIsOpen(obj->ChannelImpl, &result);
if (success == 0) {
    coderChannelHasSyncError(obj->ChannelImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(obj->ChannelImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(obj->ChannelImpl, &errorID[0], &errorText[0]);
    }
}
if (result) {
    success = coderChannelClose(obj->ChannelImpl);
    if (success == 0) {
        coderChannelHasSyncError(obj->ChannelImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(obj->ChannelImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(obj->ChannelImpl, &errorID[0], &errorText[0]);
        }
    }
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void l0bscn2j24kn(\
%assign comma = ""
%<comma>const afxtk4erg3r *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 102, fcnProtoType)>
%return fcnBuff
%endfunction

%function l0bscn2j24kn2_Fcn103(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T hasSyncError;
boolean_T result;
success = coderChannelIsOpen(obj->ChannelImpl, &result);
if (success == 0) {
    coderChannelHasSyncError(obj->ChannelImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(obj->ChannelImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(obj->ChannelImpl, &errorID[0], &errorText[0]);
    }
}
if (result) {
    success = coderChannelClose(obj->ChannelImpl);
    if (success == 0) {
        coderChannelHasSyncError(obj->ChannelImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(obj->ChannelImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(obj->ChannelImpl, &errorID[0], &errorText[0]);
        }
    }
    success = coderStreamFlush(obj->InputStream.StreamImpl);
    if (success == 0) {
        chImpl = coderStreamGetChannel(obj->InputStream.StreamImpl);
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
    success = coderStreamFlush(obj->OutputStream.StreamImpl);
    if (success == 0) {
        chImpl = coderStreamGetChannel(obj->OutputStream.StreamImpl);
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void l0bscn2j24kn2(\
%assign comma = ""
%<comma>const kw1nls53yow *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 103, fcnProtoType)>
%return fcnBuff
%endfunction

%function f4nqgwr4wk_Fcn104(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,104,0,0)
%<SLibCG_AccessArg(0 ,104, 0)>
%endif

%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&pStruct->ExampleData"], 0, 104, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void f4nqgwr4wk(\
%assign comma = ""
%<comma>i0lstc3zfvr *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 104, fcnProtoType)>
%return fcnBuff
%endfunction

%function i2mp5rbg5q_Fcn105(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,105,0,0)
%<SLibCG_AccessArg(0 ,105, 0)>
%endif

%<(SLibCGCallSubFcn("f4nqgwr4wk", ["&pStruct->InputStream"], 0, 105, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void i2mp5rbg5q(\
%assign comma = ""
%<comma>kw1nls53yow *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 105, fcnProtoType)>
%return fcnBuff
%endfunction

%function kfgd0vvt3m_Fcn106(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,106,1,0)
%<SLibCG_AccessArg(0 ,106, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,106,0,0)
%<SLibCG_AccessArg(0 ,106, 0)>
%endif

%<(SLibCGCallSubFcn("i2mp5rbg5q", ["&pStruct->UnreadDataBuffer"], 0, 106, 0))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&pStruct->ByteOrder"], 0, 106, 1))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void kfgd0vvt3m(\
%assign comma = ""
%<comma>habembxjygt *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 106, fcnProtoType)>
%return fcnBuff
%endfunction

%function i2mp5rbg5qi_Fcn107(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,107,0,0)
%<SLibCG_AccessArg(0 ,107, 0)>
%endif

%<(SLibCGCallSubFcn("f4nqgwr4wk", ["&pStruct->InputStream"], 0, 107, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void i2mp5rbg5qi(\
%assign comma = ""
%<comma>afxtk4erg3r *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 107, fcnProtoType)>
%return fcnBuff
%endfunction

%function kdctovijpz_Fcn108(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,108,6,0)
%<SLibCG_AccessArg(0 ,108, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,108,5,0)
%<SLibCG_AccessArg(0 ,108, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,108,4,0)
%<SLibCG_AccessArg(0 ,108, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,108,3,0)
%<SLibCG_AccessArg(0 ,108, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,108,2,0)
%<SLibCG_AccessArg(0 ,108, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,108,1,0)
%<SLibCG_AccessArg(0 ,108, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,108,0,0)
%<SLibCG_AccessArg(0 ,108, 0)>
%endif

%<(SLibCGCallSubFcn("ec2asd4d0o", ["&pStruct->ByteOrder"], 0, 108, 0))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&pStruct->NativeDataType"], 0, 108, 1))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&pStruct->DataFieldName"], 0, 108, 2))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&pStruct->FlowControl"], 0, 108, 3))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&pStruct->Parity"], 0, 108, 4))>;
%<(SLibCGCallSubFcn("kfgd0vvt3m", ["&pStruct->_pobj0"], 0, 108, 5))>;
%<(SLibCGCallSubFcn("i2mp5rbg5qi", ["&pStruct->_pobj1"], 0, 108, 6))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void kdctovijpz(\
%assign comma = ""
%<comma>fops2f5bc43 *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 108, fcnProtoType)>
%return fcnBuff
%endfunction

%function hbgyxopagp_Fcn109(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,109,0,0)
%<SLibCG_AccessArg(0 ,109, 0)>
%endif

%<(SLibCGCallSubFcn("kdctovijpz", ["&pStruct->SerialObj"], 0, 109, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void hbgyxopagp(\
%assign comma = ""
%<comma>evr2nhlpli *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 109, fcnProtoType)>
%return fcnBuff
%endfunction

%function l0bscn2j24_Fcn110(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T hasSyncError;
boolean_T result;
success = coderChannelIsOpen(obj->ChannelImpl, &result);
if (success == 0) {
    coderChannelHasSyncError(obj->ChannelImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(obj->ChannelImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(obj->ChannelImpl, &errorID[0], &errorText[0]);
    }
}
if (result) {
    success = coderChannelClose(obj->ChannelImpl);
    if (success == 0) {
        coderChannelHasSyncError(obj->ChannelImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(obj->ChannelImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(obj->ChannelImpl, &errorID[0], &errorText[0]);
        }
    }
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void l0bscn2j24(\
%assign comma = ""
%<comma>const afxtk4erg3 *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 110, fcnProtoType)>
%return fcnBuff
%endfunction

%function l0bscn2j24k_Fcn111(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
CoderChannel chImpl;
int32_T success;
char_T errorID[1024];
char_T errorText[1024];
boolean_T hasSyncError;
boolean_T result;
success = coderChannelIsOpen(obj->ChannelImpl, &result);
if (success == 0) {
    coderChannelHasSyncError(obj->ChannelImpl, &hasSyncError);
    if (!hasSyncError) {
        coderChannelGetLastError(obj->ChannelImpl, &errorID[0], &errorText[0]);
    } else {
        coderChannelGetLastSyncError(obj->ChannelImpl, &errorID[0], &errorText[0]);
    }
}
if (result) {
    success = coderChannelClose(obj->ChannelImpl);
    if (success == 0) {
        coderChannelHasSyncError(obj->ChannelImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(obj->ChannelImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(obj->ChannelImpl, &errorID[0], &errorText[0]);
        }
    }
    obj->TotalElementsWritten = 0.0;
    obj->InputStream.PartialPacket->size[0] = obj->InputStream.ExampleData->size[0];
    obj->InputStream.PartialPacket->size[1] = 0;
    obj->InputStream.PartialPacketStart = 0.0;
    obj->InputStream.PartialPacketCount = 0.0;
    success = coderStreamFlush(obj->InputStream.StreamImpl);
    if (success == 0) {
        chImpl = coderStreamGetChannel(obj->InputStream.StreamImpl);
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
    obj->PartialPacket->size[0] = 1;
    obj->PartialPacket->size[1] = 0;
    obj->PartialPacket->size[0] = 0;
    obj->PartialPacket->size[1] = 0;
    obj->PartialPacketStart = 0.0;
    obj->PartialPacketCount = 0.0;
    success = coderStreamFlush(obj->OutputStream.StreamImpl);
    if (success == 0) {
        chImpl = coderStreamGetChannel(obj->OutputStream.StreamImpl);
        coderChannelHasSyncError(chImpl, &hasSyncError);
        if (!hasSyncError) {
            coderChannelGetLastError(chImpl, &errorID[0], &errorText[0]);
        } else {
            coderChannelGetLastSyncError(chImpl, &errorID[0], &errorText[0]);
        }
    }
}
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void l0bscn2j24k(\
%assign comma = ""
%<comma>kw1nls53yo *obj\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 111, fcnProtoType)>
%return fcnBuff
%endfunction

%function f4nqgwr4wks_Fcn112(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,112,1,0)
%<SLibCG_AccessArg(0 ,112, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,112,0,0)
%<SLibCG_AccessArg(0 ,112, 0)>
%endif

%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&pStruct->PartialPacket"], 0, 112, 0))>;
%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&pStruct->ExampleData"], 0, 112, 1))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void f4nqgwr4wks(\
%assign comma = ""
%<comma>i0lstc3zfv *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 112, fcnProtoType)>
%return fcnBuff
%endfunction

%function i2mp5rbg5qix_Fcn113(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,113,1,0)
%<SLibCG_AccessArg(0 ,113, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,113,0,0)
%<SLibCG_AccessArg(0 ,113, 0)>
%endif

%<(SLibCGCallSubFcn("f4nqgwr4wks", ["&pStruct->InputStream"], 0, 113, 0))>;
%<(SLibCGCallSubFcn("lv0yfzd1c2", ["&pStruct->PartialPacket"], 0, 113, 1))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void i2mp5rbg5qix(\
%assign comma = ""
%<comma>kw1nls53yo *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 113, fcnProtoType)>
%return fcnBuff
%endfunction

%function kfgd0vvt3mo_Fcn114(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,114,3,0)
%<SLibCG_AccessArg(0 ,114, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,114,2,0)
%<SLibCG_AccessArg(0 ,114, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,114,1,0)
%<SLibCG_AccessArg(0 ,114, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,114,0,0)
%<SLibCG_AccessArg(0 ,114, 0)>
%endif

%<(SLibCGCallSubFcn("i2mp5rbg5qix", ["&pStruct->UnreadDataBuffer"], 0, 114, 0))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&pStruct->ByteOrder"], 0, 114, 1))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&pStruct->NativeDataType"], 0, 114, 2))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&pStruct->DataFieldName"], 0, 114, 3))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void kfgd0vvt3mo(\
%assign comma = ""
%<comma>habembxjyg *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 114, fcnProtoType)>
%return fcnBuff
%endfunction

%function i2mp5rbg5qixt_Fcn115(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,115,0,0)
%<SLibCG_AccessArg(0 ,115, 0)>
%endif

%<(SLibCGCallSubFcn("f4nqgwr4wks", ["&pStruct->InputStream"], 0, 115, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void i2mp5rbg5qixt(\
%assign comma = ""
%<comma>afxtk4erg3 *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 115, fcnProtoType)>
%return fcnBuff
%endfunction

%function kdctovijpza_Fcn116(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,116,6,0)
%<SLibCG_AccessArg(0 ,116, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,116,5,0)
%<SLibCG_AccessArg(0 ,116, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,116,4,0)
%<SLibCG_AccessArg(0 ,116, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,116,3,0)
%<SLibCG_AccessArg(0 ,116, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,116,2,0)
%<SLibCG_AccessArg(0 ,116, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,116,1,0)
%<SLibCG_AccessArg(0 ,116, 0)>
%endif

%if SLibCG_FcnCallArgAccessed(0,116,0,0)
%<SLibCG_AccessArg(0 ,116, 0)>
%endif

%<(SLibCGCallSubFcn("ec2asd4d0o", ["&pStruct->ByteOrder"], 0, 116, 0))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&pStruct->NativeDataType"], 0, 116, 1))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&pStruct->DataFieldName"], 0, 116, 2))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&pStruct->FlowControl"], 0, 116, 3))>;
%<(SLibCGCallSubFcn("ec2asd4d0o", ["&pStruct->Parity"], 0, 116, 4))>;
%<(SLibCGCallSubFcn("kfgd0vvt3mo", ["&pStruct->_pobj0"], 0, 116, 5))>;
%<(SLibCGCallSubFcn("i2mp5rbg5qixt", ["&pStruct->_pobj1"], 0, 116, 6))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void kdctovijpza(\
%assign comma = ""
%<comma>fops2f5bc4 *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 116, fcnProtoType)>
%return fcnBuff
%endfunction

%function gncli2jhsl_Fcn117(block) void
%assign fcnBuff = ""
%openfile fcnBuff
%assign cfgTxt = ""
%openfile cfgTxt
%assign _modelSS = ""

%if SLibCG_FcnCallArgAccessed(0,117,0,0)
%<SLibCG_AccessArg(0 ,117, 0)>
%endif

%<(SLibCGCallSubFcn("kdctovijpza", ["&pStruct->SerialObj"], 0, 117, 0))>;
%closefile cfgTxt
%<cfgTxt>
%closefile fcnBuff
%assign fcnProtoType = ""
%openfile fcnProtoType
static void gncli2jhsl(\
%assign comma = ""
%<comma>pry1oxlo21 *pStruct\
%assign comma = ", "
%closefile fcnProtoType
%<SLibCG_SetFcnProtoType(0, 117, fcnProtoType)>
%return fcnBuff
%endfunction

